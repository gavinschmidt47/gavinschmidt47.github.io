<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projects</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>My Projects</h1>
        
        <nav>
            <ul>
                <li><a href="#about">About</a></li>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="#contact">Contact</a></li>
                <li><a href="resume.html" target="_blank">Resume</a></li>
            </ul>
        </nav>

    </header>
    <main>
        <section id="projects">

            <h2>Projects</h2>

        <div class="project">

            <h3 style="color: #850101">BLAST SPACE</h3>

            <p><b>SOLO ORIGINAL VIDEO GAME</b></p>

            <p>Within the realms of Blast Space, the only matter of importance is your wealth of Cubes. The accumulation of this resource has created intergalactic megacorporations powerful beyond comprehension. However, they need a powerful <i>Blasters</i>, such as yourself to harvest this resources of inestimable valuable. Will you prove your worth to these corporations? Or will you waste your shot at an <i>Eternity of Peace</i></p>
            <p>The game’s mechanics are simple yet offer a challenge to players, whether new or returning. As a player, you must bide your time, waiting for the perfect moment when the maximum number of cubes are within the Blast Space. Then, with a single press of the space bar, your fate is permanently sealed, until you want to try another <i>Blaster</i>, that is. With little to no learning curve and randomized spawning, Blast Space is an easy-to-get-into game with a lot of replayability.</p>

            <p><b>WHAT I DID</b></p>
            <p>Every single aspect of this game, except for the tilemap, was made by hand for a class at UCF. We were given a week and a half to come up with a simple 'WarioWare'-inspired game and create it. I have always enjoyed timing-based games and working to beat my own or others' high scores. So, I designed a simple-looking game with fun, randomly spawning enemies that can collide with each other and move around. Since I created this project alone, I was able to ensure every aspect of the game fit my theme and worked together in harmony. The sprite of the Blaster and the enemy are meant to have a similar feeling and presence in the scene. However, they are notably different from the tilemap to create a feeling of unease and unnaturalness. Additionally, because the game is set to a timer and becomes very fast-paced, I made the music emphasize the unease and pressure of time.</p>
            <ul>
                <li>Game Design</li>
                <li>Art</li>
                <li>Music</li>
                <li>Programming</li>
            </ul>
            <iframe frameborder="0" src="https://itch.io/embed/3251631" width="552" height="167"><a href="https://elusivechicken47.itch.io/blast-space">Blast Space by ElusiveChicken47</a></iframe>
            <p></p>
            <audio controls>
                <source src="Pieces/Blast Space/Anticipation.mp3" type="audio/mpeg">
                <source src="Pieces/Blast Space/Anticipation.wav" type="audio/ogg">
                Your browser does not support the audio element.
            </audio>
            <p></p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/uIh6t6bLAhs?si=uhW3pQS7NMe5ygYy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <p></p>
            <a href="Pieces/Blast Space/Blast Space.zip" download>Download BLAST SPACE</a>
            <p></p>
            <a href="https://github.com/gavinschmidt47/Blast-Space">BLAST SPACE Github</a>
            <p><b>Credit:</b> Gavin Schmidt</P>
        <div class="project">
            <h3 style="color: #72bcd4">Bird Burglars</h3>
            <p>ORIGINAL CARD GAME</p>
            <p>Step into the thrilling world of Bird Burglars, where your mission is to amass as many precious eggs as possible. However, rival collectors are on the prowl, eager to snatch away your valuable egg makers and even the eggs you've painstakingly gathered.</p>
            <p>Set in a bustling local park, you'll need to employ every ounce of strategy and cunning. Utilize any food you can scavenge to coax the birds into performing your bidding. The game revolves around the masterful use of food cards, action cards, and bird cards to outmaneuver and outwit your opponents.</p>
            <p>But stay vigilant! Your rivals can abruptly end the round, potentially leaving you with a surplus of wasted resources.</p>
            <p>Bird Burglars demands sharp wits, tactical planning, and swift decision-making. Are you ready to dominate the egg-collecting arena and emerge as the ultimate champion?</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/7i9SrrcdcHg?si=7fR6poB8f4Flak5R" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <p>Eat Food. Steal Egg.</p>
            <a href="Pieces/Bird Burglars/Bird Burglars Rules and Parts.pdf" download>Download Bird Burglars Rules</a>
            <p></p>
            <a href="Pieces/Bird Burglars/Bird Burglars Documents.zip" download>Download Bird Burglars Documents</a>
            <p><b>Credit:</b> Mechanics, Game Design Document, Technical Writer: Gavin Schmidt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Artist, Master Art File, Playtest Video, Style Guide: Rebecca Jaffe &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Mechanics, Video Editor, Concept Document: William Everett &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Book keeper, Producer, MDA and Theme Analysis: Matthew Yang &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Story, Creative Direction: Wesley Yates</P>
        <div class="project">
            <h3 style="color: #013220">Corporate: World Dominion</h3>
            <p>MODIFIED BOARD GAME</p>
            <p>Corporate: World Dominion is a thrilling reimagining of the classic board game, Risk, where corporate conquest takes center stage. Your mission? Expand your business empire to the farthest reaches of the globe, outmaneuvering and eliminating local and global competitors by any means necessary.</p>
            <p>Players start with their Factories strategically located across different regions of the world. Utilize a dynamic economy system to strengthen your forces, seize more territories, and establish unparalleled control over your opponents.</p>
            <p>Prepare for a high-stakes battle of strategy and cunning in Corporate: World Dominion – where corporate giants are made, and only the most shrewd will prevail.</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/726tTxsHORQ?si=-EWbcnMv1i5D7d06" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            <p>In a world focused on profits and international sales, only one corporation can truly claim the World Dominion.</p>
            <a href="Pieces/Coporate World Dominion.pdf" download>Download Corporate: World Dominion rules</a>
            <p><b>Credit:</b> Mechanics, Story, and Documentation: Gavin Schmidt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Playtesting: Matthew Yang</P>
        </div>
        <div class="project">
            <h3 style="color: #00008B">FACES: COMMANDERS</h3>
            <p>ORIGINAL CARD GAME</P>
            <p>FACES: COMMANDERS is a fast-paced, head-to-head strategy game that combines the classic excitement of poker-hand card synergy with intense battlefield tactics. In this linear battle game, the strategic combination of cards unlocks additional dice, which are then rolled to determine the victor of each skirmish.</p>
            <p>Assemble formidable armies for each of your commanders—Ace, King, Queen, and Jack—by strategically adding cards, or "units," to their ranks. Leveraging unit synergy provides powerful boosts to your battle dice, giving your army the edge against opponents. Once your units are recruited, each commander faces off against their respective arch-nemesis (Aces versus Aces, Kings versus Kings, and so forth). The commander who emerges victorious in the most skirmishes claims supremacy in the epic War of Faces.</p>
            <p>Get ready to outmaneuver your rivals and lead your commanders to ultimate victory in FACES: COMMANDERS.</p>
            <a href="Pieces/FACES COMMANDERS.pdf" download>Download FACES: COMMANDERS rules</a>
            <p><b>Credit:</b> Gavin Schmidt</P>
        </div>
        <div class="project">
            <h3 style="color: #Ff4500">Two Person Microgame</h3>
            <p>MODIFIED TUTORIAL GAME</p>
            <p>This 2D top-down shooter microgame was collaboratively developed by myself and Egor Nikiforov. The game features moving enemies, NPC dialogue, and environmental hazards. Detailed credits for our individual contributions can be found in the README file.</p>
            <a href="Pieces/Partner Microgame.zip" download>Download Partner Microgame</a>
            <p><b>Credit:</b> Projectile Particles, UI, In-level Sounds, Ammo System, Level Design: Gavin Schmidt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scenery, Win/Lose Screen Music/UI, Damage Zones: Egor Nikiforov</P>
        </div>
        <div class="project">
            <h3>Unity Tutorial: FPS</h3>
            <p>ORIGINAL MUSIC</p>
            <p>My objective was to compose a triumphal gladiatorial melody, subsequently interspersed with elements of uncertainty and foreboding. Given the game's dark and enigmatic nature, I meticulously crafted both the atmospheric design and the music's darker harmonies to evoke an enduring sense of dread.</p>
            <iframe frameborder="0" src="https://itch.io/embed/3231642" width="552" height="167"><a href="https://elusivechicken47.itch.io/unity-tutorial-game">Unity Tutorial Game by ElusiveChicken47</a></iframe>
            <p></p>
            <audio controls>
                <source src="Pieces/Unity Tutorial/FPS.mp3" type="audio/mpeg">
                <source src="Pieces/Unity Tutorial/FPS.wav" type="audio/ogg">
                Your browser does not support the audio element.
            </audio>
            <p></p>
            <p><b>Credit:</b> Sound Design, VFX, Prop Placement: Gavin Schmidt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Game Design, Level Design, Scenery: Unity</P>
        </div>
        <div class="project">
            <h3>Breadth First Search</h3>
            <p>PROBLEM SOLVING CODE</p>
            <p><b>Problem:</b></p>
            <p>The first line of input contains two space separated integers, r (2 ≤ r ≤ 1000) and c (2 ≤ c ≤ 1000), representing the number of rows and number of columns in the grid, respectively.</p>
            <p>The following r lines contain c characters each. The ith line of these lines contains the contents of the ith row of the grid, from left to right.</p>
            <p>It is guaranteed that exactly one of the grid characters will be ‘*’ and exactly one of the grid characters will be ‘$’. All grid characters that represent regular squares will be labeled with the character ‘.’. All forbidden squares will be represented with the grid character ‘!’. All other squares will be capital letters, representing various teleportation squares. If a letter appears in the grid, then it will appear in at least two separate grid squares.</p>
            <p>The Output (standard console output): If Gustavo can get out of the maze, output a single integer representing the fewest number of moves it will takehim to get out. If he can’t get out, output “Call 911”.</p>
            <details>
                <summary>Code</summary>
            <pre><code>import java.util.*;

class Main {
    final public static int[] DR = {-1,0,1,0};
    final public static int[] DC = {0,-1,0,1};
                
    public static int r;
    public static int c;
    public static char[][] maze;
                
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
                
        r = in.nextInt();
        c = in.nextInt();
                
        maze = new char[r][c];
                
        for(int i=0; i < r; ++i){
            maze[i] = in.next().toCharArray();
        }
                
        int start = find('*');
                
        int result = bfs(start, '$');
        if (result == -1)
            System.out.println("Call 911");
        else
            System.out.println(result);
    }
                
    public static int bfs(int s, char e){
        LinkedList<Integer> q = new LinkedList<Integer>();
        q.offer(s);
                        
        int[] dist = new int[r*c];
        Arrays.fill(dist, -1);
        dist[s] = 0;
                
        while(q.size()>0){
            int curr = q.poll();
                
            int currR = curr / c;
            int currC = curr % c;
                
            char currL = maze[currR][currC];
                
            if (currL == e) return dist[curr];
                
            for (int i=0; i < DR.length; i++) {
                int nR = currR + DR[i];
                int nC = currC + DC[i];
                
                if (!inbounds(nR, nC)) continue;
                if (maze[nR][nC] == '!') continue;
                if (dist[nR*c+nC] != -1) continue;
                
                dist[nR*c+nC] = dist[curr] + 1;
                q.offer(nR*c+nC);
            }
                
            if('A' <= currL){
                if(currL <= 'Z'){
                    int letterPlus = find((char)(currL + 1));
                    int letterNeg = find((char)(currL - 1));
                    if(letterPlus != -1){
                        int nR = letterPlus / c;
                        int nC = letterPlus % c;
            
                        if (dist[letterPlus] != -1) continue;
                
                        dist[letterPlus] = dist[curr] + 1;
                        q.offer(letterPlus);
                    }
                
                    if(letterNeg != -1){
                        int nR = letterNeg / c;
                        int nC = letterNeg % c;
                
                        if (dist[letterNeg] != -1) continue;
                
                        dist[letterNeg] = dist[curr] + 1;
                        q.offer(letterNeg);
                    } 
                }
            }
        }
        return -1;
    }
                
    public static boolean inbounds(int x, int y) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }
                
    public static int find(char s){
        for (int i=0; i < r; i++)
            for (int j=0; j < c; j++)
                if (maze[i][j] == s)
                    return i*c + j;
                return -1;
    }
                
    // FOR TESTING
    public static void printMaze(){
        for(int i=0; i < r; ++i){
            for(int j=0; j < c; ++j){
                System.out.print(maze[i][j]);
            }
            System.out.println();
        }
    }
}
            </pre></code>
            </details>
        </div>
        <div class="project">
            <h3>Dijkstra's Algorithm</h3>
            <p>PROBLEM SOLVING CODE</p>
            <p><b>Problem:</b></p>
            <p>The first line of input contains 3 space separated integers, C (2 ≤C≤105), R (C-1 ≤ R≤ min(105, n(n-1)/2), S (1 ≤ S ≤ N), representing the number of cities, number of roads, and the city number that represents the capital, respectively.</p>
            <p>Then the next R lines contain the descriptions of the roads. Each of them contains 3 space separated integers vi, ui, wi (1 ≤ vi, ui ≤ n, vi ≠ ui, 1 ≤ wi ≤ 1000), where vi, ui are numbers of the cities connected by this road and wi is its length. The last input line contains integer L (0 ≤ l ≤ 109) — the distance from the capital to the places where the treasures are located. It is guaranteed that:</p>
            <p>• between any two cities no more than one road exists.</p>
            <p>• each road connects two different cities.</p>
            <p>• from each city there is at least one way to any other city by the roads.</p>
            <p>The Output (standard console output): Print two numbers — the number of treasures in the cities and the number of treasures on the roads in Monster land.</p>
            <details>
                <summary>Code</summary>
            <pre><code>import java.util.*;

class Main {
    //global variables
    public static int C;
    public static int R;
    public static int CAPITAL;
    public static int[][] graph;
    public static int L;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
                
        //getting num of cities, roads, and where capital
        C = in.nextInt();
        R = in.nextInt();
        CAPITAL = in.nextInt() - 1;
                
        //setup adjacency matrix
        graph = new int[C][C];
                
                
        //integers to setup up matrix
        int tempC1;
        int tempC2;
        int length;
                
        //build matrix
        for(int i = 0; i < R; ++i){
            tempC1 = in.nextInt() - 1;
            tempC2 = in.nextInt() - 1;
            length = in.nextInt();
                
            //into matrix
            graph[tempC1][tempC2] = length;
            graph[tempC2][tempC1] = length;
        }
                
        //getting L
        L = in.nextInt();
                
        //close input
        in.close();
                
        Dijkstra();
    }
    public static void Dijkstra() {
        //three lists to track during algorithm
        PriorityQueue<City> minHeap = new PriorityQueue<City>(C, new City());
        int[] D = new int[C];
        Set<Integer> S = new HashSet<Integer>();
                
        //three lists to track treasure
        int[] roadT = new int[C];
        int tCity = 0;
        int tRoad = 0;
                
        //start all distances at INF
        Arrays.fill(D,Integer.MAX_VALUE);
                
        //start with capital
        minHeap.add(new City(CAPITAL, 0));
        D[CAPITAL] = 0;
                
        int prevD;
                
        while (S.size() != C){
            //visit next node in minHeap
            int next = minHeap.poll().c;
                
            if(S.contains(next))
                continue;
                
            //add to visited list
            S.add(next);
                
            for(int i = 0; i < C; ++i){
                if(graph[next][i] > 0 && i != CAPITAL){
                                    
                    //if treasure is on road
                    //System.out.println(next + ": " + D[next] + " " + i + ": " + D[i]);
                    if(D[next] < L && (D[next] + graph[next][i]) > L){
                        roadT[next] = L - D[next];
                        if(roadT[next] != roadT[i] || roadT[next] != graph[next][i] / 2){
                            //System.out.println("adding");
                            tRoad++;
                        }
                    }
                
                    //if smaller, update D, add to minHeap
                    if(D[i] > (D[next] + graph[next][i])){
                        prevD = D[i];
                        D[i] = D[next] + graph[next][i];
                        minHeap.add(new City(i, D[i]));
                
                        //treasure found
                        if(D[i] == L)
                            ++tCity; 
                        if(prevD == L && D[i] != L)
                            --tCity;
                                        
                    } 
                    //System.out.println(next + ": " + D[next] + " " + i + ": " + D[i]);
                }
            }
        }
        System.out.println("In city: " + tCity);
        System.out.println("On the road: " + tRoad);
    }
}
                
//object for minheap
class City implements Comparator<City>{
    public int c;
    public int d;
                
    public City(){
    }
                
    public City(int c, int d){
        this.c = c;
        this.d = d;
    }
                
    @Override
    public int compare(City node1, City node2) {
        if (node1.d < node2.d)
            return -1;
        if (node1.d > node2.d)
            return 1;
        return 0;
    }
}
            </pre></code>
        </details>
        </div>
        <div class="project">
            <h3>Dynamic Programming</h3>
            <p>PROBLEM SOLVING CODE</p>
            <p><b>Problem:</b></p>
            <p>The first line of the input contains a single integer n (1≤n≤100000) that represents the number of students in each row.</p>
            <p>The second line of the input contains n integers p1,1,p1,2,...,p1,n,(1≤p1,i≤109), where p1,i is the number of problems solved by the ith student in the first row.</p>
            <p>The third line of the input contains n integers p2,1,p2,2,...,p2,n,(1≤p2,i≤109), where p2,i is the number of problems solved by the ith student in the second row.</p>
            <p>The Output (standard console output): Print one number — the maximum possible total problem solved by the selected group of students.</p>
            <details>
                <summary>Code</summary>
            <pre><code>import java.util.*;

public class Main {
    public static int[][] candidates;
    public static int size;
    public static void main(String [] args){
        Scanner in = new Scanner(System.in);
                
        size = in.nextInt();
        candidates = new int[size][2];
                
        for(int i = 0; i < size; ++i)
            candidates[i][0] = in.nextInt();
                        
        for(int i = 0; i < size; ++i)
            candidates[i][1] = in.nextInt();
                
        System.out.println(DP());
    }
                
    public static int DP(){
        int[][] dp = new int[size][2];
                
        dp[0][0] = candidates[0][0];
        dp[0][1] = candidates[0][1];
                
        for (int i = 1; i < size; ++i){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + candidates[i][0]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + candidates[i][1]);
        }
        return Math.max(dp[size-1][0], dp[size-1][1]);
    }
}
            </pre></code>
        </details>
        </div>
        </section>
    </main>
    <footer>
        <p>&copy; 2023 Gavin Schmidt</p>
    </footer>
</body>
</html>