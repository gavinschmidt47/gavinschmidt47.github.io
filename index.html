<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gavin Schmidt's Portfolio</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Gavin Schmidt's Portfolio</h1>
        <nav>
            <ul>
                <li><a href="#about">About</a></li>
                <li><a href="#projects">Projects</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>
    <section id="about">
        <h2>About Me</h2>
        <p>Welcome to my portfolio! I am a student at the University of Central Florida studying in Digital Media - Game Design with a focus on programming. I am also minoring in Computer Science. I am enterring into my senior level clases and I will graduate May 2026. This portfolio showcases much of my classwork I have done, as well as personal projects. Much of my work is focused on the coding, but I notate where I did other parts of the project.</p>
        <p>I decided to become a Game Design major because of my passion for video games from a young age and what you can achieve through such a medium. Creativity and logistics are exactly what I strive to achieve in everything I do and video games are that perfect intersection. I have ensured that I am a valuable asset to every possible part of the development process and to the company as a whole. I have worked as much as I can in between schooling to gain broad experience throughout a multitude of industries in order to obtain the skills necessary to complete any task given to me throughout my career. I have no doubt that I can bring something to the table in every situation.</p>
    </section>
    <section id="projects">
        <h2>Projects</h2>
        <div class="project">
            <h3 style="color: #013220">Corporate: World Dominion</h3>
            <p>A reworking of the classic board game, Risk, Corporate: World Dominion offers a more Monopolistic conflict. Your goal is to spread your business as far as possible and to eliminate local and global competition through any means necessary.</p>
            <a href="https://youtu.be/726tTxsHORQ">Gameplay video</a>
            <p>In a world focused on profits and international sales, only one corporation can truly claim the World Dominion.</p>
            <a href="Coporate World Dominion.pdf" download>Download Corporate: World Dominion rules</a>
        </div>
        <div class="project">
            <h3 style="color: #00008B">FACES: COMMANDERS</h3>
            <p>A linear battle game using poker-hand card synergy, FACES: COMMANDERS is a quick head-to-head strategy game. Combining card synergies allows for more dice which then get rolled to determine who wins each battle.</p>
            <p>Create armies for each of your commanders to fight enemy commanders by adding cards, or “units”, underneath each commander. Your commanders are Ace, King, Queen, and Jack. Using unit synergy can provide boosts to your battle dice to give your army a leg up against the opponent(s). After recruiting your units, each commander will compete against its respective arch nemesis (Ace will fight all enemy Aces, King will fight all enemy Kings, etc.). Whoever survives the most skirmishes wins the War of Faces.</p>
            <a href="FACES COMMANDERS.pdf" download>Download FACES: COMMANDERS rules</a>
        </div>
        <!--<div class="project">
            <h3>Unity Tutorial: FPS</h3>
            <p>An FPS game I tweaked and changed to be learn Unity.</p>
            <p>FIRST CHANGE:</p>
            <p></p>
            <a href="FACES COMMANDERS.pdf" download>Download FACES: COMMANDERS rules</a>
        </div>-->
        <div class="project">
            <h3>Breadth First Search</h3>
            <p>The first line of input contains two space separated integers, r (2 ≤ r ≤ 1000) and c (2 ≤ c ≤ 1000), representing the number of rows and number of columns in the grid, respectively.</p>
            <p>The following r lines contain c characters each. The ith line of these lines contains the contents of the ith row of the grid, from left to right.</p>
            <p>It is guaranteed that exactly one of the grid characters will be ‘*’ and exactly one of the grid characters will be ‘$’. All grid characters that represent regular squares will be labeled with the character ‘.’. All forbidden squares will be represented with the grid character ‘!’. All other squares will be capital letters, representing various teleportation squares. If a letter appears in the grid, then it will appear in at least two separate grid squares.</p>
            <p>The Output (standard console output): If Gustavo can get out of the maze, output a single integer representing the fewest number of moves it will takehim to get out. If he can’t get out, output “Call 911”.</p>
            <pre><code>import java.util.*;

                class Main {
                    final public static int[] DR = {-1,0,1,0};
                    final public static int[] DC = {0,-1,0,1};
                
                    public static int r;
                    public static int c;
                    public static char[][] maze;
                
                    public static void main(String[] args) {
                        Scanner in = new Scanner(System.in);
                
                        r = in.nextInt();
                        c = in.nextInt();
                
                        maze = new char[r][c];
                
                        for(int i=0; i < r; ++i){
                            maze[i] = in.next().toCharArray();
                        }
                
                        int start = find('*');
                
                        int result = bfs(start, '$');
                        if (result == -1)
                            System.out.println("Call 911");
                        else
                            System.out.println(result);
                    }
                
                    public static int bfs(int s, char e){
                        LinkedList<Integer> q = new LinkedList<Integer>();
                        q.offer(s);
                        
                        int[] dist = new int[r*c];
                        Arrays.fill(dist, -1);
                        dist[s] = 0;
                
                        while(q.size()>0){
                            int curr = q.poll();
                
                            int currR = curr / c;
                            int currC = curr % c;
                
                            char currL = maze[currR][currC];
                
                            if (currL == e) return dist[curr];
                
                            for (int i=0; i<DR.length; i++) {
                                int nR = currR + DR[i];
                                int nC = currC + DC[i];
                
                                if (!inbounds(nR, nC)) continue;
                                if (maze[nR][nC] == '!') continue;
                                if (dist[nR*c+nC] != -1) continue;
                
                                dist[nR*c+nC] = dist[curr] + 1;
                                q.offer(nR*c+nC);
                            }
                
                            if('A' <= currL){
                                if(currL <= 'Z'){
                                    int letterPlus = find((char)(currL + 1));
                                    int letterNeg = find((char)(currL - 1));
                                    if(letterPlus != -1){
                                        int nR = letterPlus / c;
                                        int nC = letterPlus % c;
                
                                        if (dist[letterPlus] != -1) continue;
                
                                        dist[letterPlus] = dist[curr] + 1;
                                        q.offer(letterPlus);
                                    }
                
                                    if(letterNeg != -1){
                                        int nR = letterNeg / c;
                                        int nC = letterNeg % c;
                
                                        if (dist[letterNeg] != -1) continue;
                
                                        dist[letterNeg] = dist[curr] + 1;
                                        q.offer(letterNeg);
                                    } 
                                }
                            }
                        }
                        return -1;
                    }
                
                    public static boolean inbounds(int x, int y) {
                        return x >= 0 && x < r && y >= 0 && y < c;
                    }
                
                    public static int find(char s){
                        for (int i=0; i < r; i++)
                            for (int j=0; j < c; j++)
                                if (maze[i][j] == s)
                                    return i*c + j;
                        return -1;
                    }
                
                    // FOR TESTING
                    public static void printMaze(){
                        for(int i=0; i < r; ++i){
                            for(int j=0; j < c; ++j){
                                System.out.print(maze[i][j]);
                            }
                            System.out.println();
                        }
                    }
                }
            </pre></code>
        </div>
        <div class="project">
            <h3>Dijkstra's Algorithm</h3>
            <p>The first line of input contains 3 space separated integers, C (2 ≤C≤105), R (C-1 ≤ R≤ min(105, n(n-1)/2), S (1 ≤ S ≤ N), representing the number of cities, number of roads, and the city number that represents the capital, respectively.</p>
            <p>Then the next R lines contain the descriptions of the roads. Each of them contains 3 space separated integers vi, ui, wi (1 ≤ vi, ui ≤ n, vi ≠ ui, 1 ≤ wi ≤ 1000), where vi, ui are numbers of the cities connected by this road and wi is its length. The last input line contains integer L (0 ≤ l ≤ 109) — the distance from the capital to the places where the treasures are located. It is guaranteed that:</p>
            <p>• between any two cities no more than one road exists.</p>
            <p>• each road connects two different cities.</p>
            <p>• from each city there is at least one way to any other city by the roads.</p>
            <p>The Output (standard console output): Print two numbers — the number of treasures in the cities and the number of treasures on the roads in Monster land.</p>
            <pre><code>import java.util.*;

                class Main {
                    //global variables
                    public static int C;
                    public static int R;
                    public static int CAPITAL;
                    public static int[][] graph;
                    public static int L;
                    public static void main(String[] args) {
                        Scanner in = new Scanner(System.in);
                
                        //getting num of cities, roads, and where capital
                        C = in.nextInt();
                        R = in.nextInt();
                        CAPITAL = in.nextInt() - 1;
                
                        //setup adjacency matrix
                        graph = new int[C][C];
                
                
                        //integers to setup up matrix
                        int tempC1;
                        int tempC2;
                        int length;
                
                        //build matrix
                        for(int i = 0; i < R; ++i){
                            tempC1 = in.nextInt() - 1;
                            tempC2 = in.nextInt() - 1;
                            length = in.nextInt();
                
                            //into matrix
                            graph[tempC1][tempC2] = length;
                            graph[tempC2][tempC1] = length;
                        }
                
                        //getting L
                        L = in.nextInt();
                
                        //close input
                        in.close();
                
                        Dijkstra();
                    }
                    public static void Dijkstra() {
                        //three lists to track during algorithm
                        PriorityQueue<City> minHeap = new PriorityQueue<City>(C, new City());
                        int[] D = new int[C];
                        Set<Integer> S = new HashSet<Integer>();
                
                        //three lists to track treasure
                        int[] roadT = new int[C];
                        int tCity = 0;
                        int tRoad = 0;
                
                        //start all distances at INF
                        Arrays.fill(D,Integer.MAX_VALUE);
                
                        //start with capital
                        minHeap.add(new City(CAPITAL, 0));
                        D[CAPITAL] = 0;
                
                        int prevD;
                
                        while (S.size() != C){
                            //visit next node in minHeap
                            int next = minHeap.poll().c;
                
                            if(S.contains(next)){
                                continue;
                            }
                
                            //add to visited list
                            S.add(next);
                
                            for(int i = 0; i < C; ++i){
                                if(graph[next][i] > 0 && i != CAPITAL){
                                    
                                    //if treasure is on road
                                    //System.out.println(next + ": " + D[next] + " " + i + ": " + D[i]);
                                    if(D[next] < L && (D[next] + graph[next][i]) > L){
                                        roadT[next] = L - D[next];
                                            if(roadT[next] != roadT[i] || roadT[next] != graph[next][i] / 2){
                                                //System.out.println("adding");
                                                tRoad++;
                                            }
                                        }
                
                                    //if smaller, update D, add to minHeap
                                    if(D[i] > (D[next] + graph[next][i])){
                                        prevD = D[i];
                                        D[i] = D[next] + graph[next][i];
                                        minHeap.add(new City(i, D[i]));
                
                                        //treasure found
                                        if(D[i] == L){
                                            ++tCity;
                                        } 
                                        if(prevD == L && D[i] != L){
                                            --tCity;
                                        }
                                        
                                    } 
                                    //System.out.println(next + ": " + D[next] + " " + i + ": " + D[i]);
                                }
                            }
                        }
                        System.out.println("In city: " + tCity);
                        System.out.println("On the road: " + tRoad);
                    }
                }
                
                //object for minheap
                class City implements Comparator<City>{
                    public int c;
                    public int d;
                
                    public City(){
                    }
                
                    public City(int c, int d){
                        this.c = c;
                        this.d = d;
                    }
                
                    @Override
                    public int compare(City node1, City node2) {
                    if (node1.d < node2.d)
                       return -1;
                    if (node1.d > node2.d)
                        return 1;
                    return 0;
                    }
                }
            </pre></code>
        </div>
        <div class="project">
            <h3>Dynamic Programming 6</h3>
            <p>The first line of the input contains a single integer n (1≤n≤100000) that represents the number of students in each row.</p>
            <p>The second line of the input contains n integers p1,1,p1,2,...,p1,n,(1≤p1,i≤109), where p1,i is the number of problems solved by the ith student in the first row.</p>
            <p>The third line of the input contains n integers p2,1,p2,2,...,p2,n,(1≤p2,i≤109), where p2,i is the number of problems solved by the ith student in the second row.</p>
            <p>The Output (standard console output): Print one number — the maximum possible total problem solved by the selected group of students.</p>
            <pre><code>import java.util.*;

                public class Main {
                    public static int[][] candidates;
                    public static int size;
                    public static void main(String [] args){
                        Scanner in = new Scanner(System.in);
                
                        size = in.nextInt();
                        candidates = new int[size][2];
                
                        for(int i = 0; i < size; ++i)
                            candidates[i][0] = in.nextInt();
                        
                        for(int i = 0; i < size; ++i)
                            candidates[i][1] = in.nextInt();
                
                        System.out.println(DP());
                    }
                
                    public static int DP(){
                        int[][] dp = new int[size][2];
                
                        dp[0][0] = candidates[0][0];
                        dp[0][1] = candidates[0][1];
                
                        for (int i = 1; i < size; ++i){
                            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + candidates[i][0]);
                            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + candidates[i][1]);
                        }
                        return Math.max(dp[size-1][0], dp[size-1][1]);
                    }
                }
            </pre></code>
        </div>
    </section>
    <section id="contact">
        <h2>Contact</h2>
        <div class="contact-buttons">
            <a href="mailto:gavinschmidt47@yahoo.com" class="button">
                <img src="email.png" alt="Email">
            </a>
            <a href="https://github.com/gavinschmidt47" class="button">
                <img src="github.png" alt="Github">
            </a>
            <a href="https://www.linkedin.com/in/gavin-schmidt-11b1a225a/" class="button">
                <img src="linkedin.png" alt="LinkedIn">
            </a>
            <a href="https://profile.indeed.com/?hl=en_US&co=US&from=gnav-homepage" class="button">
                <img src="indeed.png" alt="Indeed">
            </a>
        </div>
    </section>
    <footer>
        <p>&copy; 2024 Gavin Schmidt's Portfolio</p>
    </footer>
</body>
</html>