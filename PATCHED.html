<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C47TXLXECX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-C47TXLXECX');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Gavin Schmidt's Portfolio - PATCHED</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
</head>
<body class="patched-page">
    
    <!-- Static Background -->
    <div class="static-background"></div>
    
    <!-- Modern Header -->
    <header class="main-header">
        <div class="header-container">
            <div class="header-brand">
                <a href="index.html" class="brand-link">
                    <span class="brand-name">Gavin Schmidt</span>
                    <span class="brand-subtitle">Game Designer, Composer, Programmer, and Software Engineer</span>
                </a>
            </div>

            <button class="hamburger" id="hamburger-menu" aria-label="Toggle navigation menu">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>

            <nav class="main-nav" id="main-nav">
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a href="index.html" class="nav-link">
                            <span class="nav-icon">üè†</span>
                            <span class="nav-text">Home</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="projects.html" class="nav-link">
                            <span class="nav-icon">üéÆ</span>
                            <span class="nav-text">Projects</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="experience.html" class="nav-link">
                            <span class="nav-icon">üíº</span>
                            <span class="nav-text">Work</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="music.html" class="nav-link">
                            <span class="nav-icon">üéµ</span>
                            <span class="nav-text">Music</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="index.html#contact" class="nav-link">
                            <span class="nav-icon">üìß</span>
                            <span class="nav-text">Contact</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="resume.html" class="nav-link nav-link-highlight">
                            <span class="nav-icon">üìÑ</span>
                            <span class="nav-text">Resume</span>
                        </a>
                    </li>
                </ul>
            </nav>
        </div>
    </header>
    
    <main class="patched-showcase">
        <div class="hero-section">
            <div class="jam-badge">
                <span class="badge-text">üéÆ Ghost Knights Project</span>
            </div>
            <h1 class="project-title">PATCHED</h1>
            <p class="project-tagline">3D Horror Platformer ‚Ä¢ Corruption & Identity ‚Ä¢ Factory Mystery</p>
        </div>

        <section class="project-overview-section">
            <h2>Project Overview</h2>
            <p class="overview-text">
                <strong>PATCHED</strong> is an atmospheric 3D horror platformer that follows a small toy's desperate 
                struggle to escape corruption and piece itself back together‚Äîboth literally and figuratively. Navigate 
                through the haunting corridors of an abandoned factory while avoiding spreading corruption, collecting 
                scattered patches to restore yourself, and uncovering the dark secrets of your creation.
            </p>
            <p class="overview-text">
                Developed by <strong>Ghost Knights</strong>, PATCHED combines precision platforming with environmental 
                storytelling and psychological horror. Players must carefully manage their deteriorating state while 
                exploring a factory that grows increasingly disturbing as the truth emerges.
            </p>
        </section>

        <section class="features-grid-section">
            <h2>Core Features</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <h3>üß© Corruption Mechanics</h3>
                    <p>Avoid spreading corruption zones that threaten to consume you. Each corrupted patch changes your abilities and perception.</p>
                </div>
                <div class="feature-card">
                    <h3>üéØ Precision Platforming</h3>
                    <p>Navigate treacherous factory environments with tight, responsive 3D platforming controls optimized for challenging gameplay.</p>
                </div>
                <div class="feature-card">
                    <h3>üìñ Environmental Lore</h3>
                    <p>Piece together the factory's dark history through environmental clues, collectibles, and unsettling discoveries.</p>
                </div>
                <div class="feature-card">
                    <h3>üîß Patch Collection System</h3>
                    <p>Collect scattered patches to restore your physical form and unlock new abilities while uncovering memory fragments.</p>
                </div>
            </div>
        </section>

        <section class="technical-highlights-section">
            <h2>Technical Highlights</h2>
            <div class="highlight-grid">
                <div class="highlight-card">
                    <h3>‚ö° Performance Optimization</h3>
                    <p>
                        As the technical lead, I conducted extensive profiling and optimization to maintain <strong>60 FPS</strong> 
                        on mid-range hardware despite complex corruption visual effects and dynamic lighting. Reduced memory 
                        overhead by <strong>35%</strong> through careful refactoring of material systems and object pooling.
                    </p>
                </div>
                <div class="highlight-card">
                    <h3>üé® Corruption Shader System</h3>
                    <p>
                        Developed a dynamic shader system that gradually corrupts the player's appearance and the environment. 
                        The system uses vertex displacement and procedural noise to create organic, spreading corruption effects.
                    </p>
                </div>
                <div class="highlight-card">
                    <h3>üèÉ Character Controller</h3>
                    <p>
                        Built a responsive 3D platformer controller with tight aerial control, wall-sliding mechanics, and 
                        corruption-triggered movement alterations. Implemented state machine for smooth animation blending.
                    </p>
                </div>
                <div class="highlight-card">
                    <h3>üêõ Bug Tracking & Workflow</h3>
                    <p>
                        Implemented comprehensive bug tracking system that reduced average issue resolution time by <strong>45%</strong>. 
                        Established code review practices and mentored team members on debugging techniques.
                    </p>
                </div>
            </div>
        </section>

        <section class="code-examples-section">
            <h2>Code Examples</h2>
            
            <details class="code-feature">
                <summary>Corruption Spread System</summary>
                <p>
                    The corruption system uses a radius-based detection system combined with surface shaders to create 
                    organic spreading corruption zones. This implementation balances visual fidelity with performance 
                    through efficient proximity checking and shader optimization.
                </p>
                <pre><code class="language-csharp">using UnityEngine;
using System.Collections.Generic;

public class CorruptionManager : MonoBehaviour
{
    [Header("Corruption Settings")]
    [SerializeField] private float corruptionRadius = 5f;
    [SerializeField] private float spreadSpeed = 0.5f;
    [SerializeField] private float damageInterval = 1f;
    
    private List&lt;CorruptionZone&gt; activeZones = new List&lt;CorruptionZone&gt;();
    private PlayerController player;
    private float lastDamageTime;

    private void Start()
    {
        player = FindObjectOfType&lt;PlayerController&gt;();
        InitializeCorruptionZones();
    }

    private void Update()
    {
        UpdateCorruptionSpread();
        CheckPlayerInCorruption();
    }

    private void UpdateCorruptionSpread()
    {
        foreach (var zone in activeZones)
        {
            // Gradually expand corruption radius
            zone.CurrentRadius = Mathf.Min(
                zone.CurrentRadius + spreadSpeed * Time.deltaTime,
                zone.MaxRadius
            );
            
            // Update shader properties for visual effect
            zone.CorruptionMaterial.SetFloat("_CorruptionRadius", zone.CurrentRadius);
            zone.CorruptionMaterial.SetVector("_CorruptionCenter", zone.transform.position);
        }
    }

    private void CheckPlayerInCorruption()
    {
        bool inCorruption = false;
        
        foreach (var zone in activeZones)
        {
            float distance = Vector3.Distance(player.transform.position, zone.transform.position);
            
            if (distance <= zone.CurrentRadius)
            {
                inCorruption = true;
                
                // Apply damage at intervals
                if (Time.time - lastDamageTime >= damageInterval)
                {
                    player.ApplyCorruptionDamage(zone.DamagePerTick);
                    lastDamageTime = Time.time;
                }
                
                // Apply visual corruption effect
                player.UpdateCorruptionLevel(CalculateCorruptionIntensity(distance, zone.CurrentRadius));
                break;
            }
        }
        
        if (!inCorruption)
        {
            player.DecayCorruption();
        }
    }

    private float CalculateCorruptionIntensity(float distance, float radius)
    {
        // Inverse square falloff for more dramatic effect near center
        float normalizedDist = distance / radius;
        return Mathf.Pow(1f - normalizedDist, 2f);
    }

    public void RegisterCorruptionZone(CorruptionZone zone)
    {
        if (!activeZones.Contains(zone))
        {
            activeZones.Add(zone);
        }
    }
}

[System.Serializable]
public class CorruptionZone
{
    public Transform transform;
    public Material CorruptionMaterial;
    public float CurrentRadius;
    public float MaxRadius = 10f;
    public float DamagePerTick = 5f;
}</code></pre>
            </details>

            <details class="code-feature">
                <summary>Optimized Object Pooling</summary>
                <p>
                    To maintain 60 FPS with numerous collectible patches and corruption particles, I implemented an 
                    object pooling system that reduced instantiation overhead and improved memory management. This 
                    was a key optimization that contributed to the 35% memory reduction.
                </p>
                <pre><code class="language-csharp">using UnityEngine;
using System.Collections.Generic;

public class OptimizedObjectPool : MonoBehaviour
{
    [Header("Pool Settings")]
    [SerializeField] private GameObject prefab;
    [SerializeField] private int initialPoolSize = 20;
    [SerializeField] private int maxPoolSize = 100;
    [SerializeField] private bool allowGrowth = true;

    private Queue&lt;GameObject&gt; availableObjects;
    private List&lt;GameObject&gt; activeObjects;
    private Transform poolContainer;

    private void Awake()
    {
        InitializePool();
    }

    private void InitializePool()
    {
        availableObjects = new Queue&lt;GameObject&gt;(initialPoolSize);
        activeObjects = new List&lt;GameObject&gt;(initialPoolSize);
        
        // Create container for organization
        poolContainer = new GameObject($"{prefab.name}_Pool").transform;
        poolContainer.SetParent(transform);
        
        // Pre-instantiate objects
        for (int i = 0; i < initialPoolSize; i++)
        {
            CreatePooledObject();
        }
    }

    private GameObject CreatePooledObject()
    {
        GameObject obj = Instantiate(prefab, poolContainer);
        obj.SetActive(false);
        
        // Add poolable component for tracking
        var poolable = obj.GetComponent&lt;IPoolable&gt;();
        if (poolable != null)
        {
            poolable.SetPool(this);
        }
        
        availableObjects.Enqueue(obj);
        return obj;
    }

    public GameObject Get(Vector3 position, Quaternion rotation)
    {
        GameObject obj;
        
        // Reuse existing object or create new one
        if (availableObjects.Count > 0)
        {
            obj = availableObjects.Dequeue();
        }
        else if (allowGrowth && activeObjects.Count < maxPoolSize)
        {
            obj = CreatePooledObject();
            availableObjects.Dequeue(); // Remove from queue since we're using it immediately
        }
        else
        {
            Debug.LogWarning($"Pool for {prefab.name} exhausted. Consider increasing pool size.");
            return null;
        }
        
        // Reset and activate
        obj.transform.position = position;
        obj.transform.rotation = rotation;
        obj.SetActive(true);
        
        activeObjects.Add(obj);
        
        // Notify poolable component
        var poolable = obj.GetComponent&lt;IPoolable&gt;();
        poolable?.OnSpawnFromPool();
        
        return obj;
    }

    public void Return(GameObject obj)
    {
        if (!activeObjects.Contains(obj))
        {
            Debug.LogWarning($"Attempting to return object that doesn't belong to this pool: {obj.name}");
            return;
        }
        
        // Notify poolable component
        var poolable = obj.GetComponent&lt;IPoolable&gt;();
        poolable?.OnReturnToPool();
        
        // Deactivate and return to pool
        obj.SetActive(false);
        obj.transform.SetParent(poolContainer);
        
        activeObjects.Remove(obj);
        availableObjects.Enqueue(obj);
    }

    // Performance metrics for debugging
    public int ActiveCount => activeObjects.Count;
    public int AvailableCount => availableObjects.Count;
    public int TotalCount => ActiveCount + AvailableCount;
}

public interface IPoolable
{
    void SetPool(OptimizedObjectPool pool);
    void OnSpawnFromPool();
    void OnReturnToPool();
}</code></pre>
            </details>

            <details class="code-feature">
                <summary>Performance Profiling System</summary>
                <p>
                    Implemented a custom profiling system to identify hotspots and bottlenecks across the game's 
                    systems. This tool was instrumental in achieving the performance targets and mentoring team 
                    members on optimization techniques.
                </p>
                <pre><code class="language-csharp">using UnityEngine;
using System.Collections.Generic;
using System.Diagnostics;
using Debug = UnityEngine.Debug;

public class PerformanceProfiler : MonoBehaviour
{
    private static PerformanceProfiler instance;
    private Dictionary&lt;string, ProfilerData&gt; profiledSystems;
    private bool isEnabled = true;

    [Header("Display Settings")]
    [SerializeField] private bool showOnScreen = true;
    [SerializeField] private KeyCode toggleKey = KeyCode.F3;
    
    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);
            profiledSystems = new Dictionary&lt;string, ProfilerData&gt;();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Update()
    {
        if (Input.GetKeyDown(toggleKey))
        {
            showOnScreen = !showOnScreen;
        }
    }

    private void OnGUI()
    {
        if (!showOnScreen || !isEnabled) return;
        
        int yOffset = 10;
        GUI.Label(new Rect(10, yOffset, 500, 20), 
            $"Performance Profiler - Frame: {Time.frameCount} | FPS: {1f / Time.deltaTime:F1}");
        yOffset += 25;
        
        GUI.Label(new Rect(10, yOffset, 500, 20), "System | Avg (ms) | Peak (ms) | Calls");
        yOffset += 20;
        
        foreach (var kvp in profiledSystems)
        {
            var data = kvp.Value;
            string display = $"{kvp.Key} | {data.AverageMs:F3} | {data.PeakMs:F3} | {data.CallCount}";
            GUI.Label(new Rect(10, yOffset, 500, 20), display);
            yOffset += 20;
            
            // Warning for high-cost systems
            if (data.AverageMs > 5f)
            {
                GUI.color = Color.red;
                GUI.Label(new Rect(520, yOffset - 20, 200, 20), "‚ö† HIGH COST");
                GUI.color = Color.white;
            }
        }
    }

    public static ProfilerToken BeginSample(string sampleName)
    {
        if (instance == null || !instance.isEnabled) 
            return new ProfilerToken(null, null);
            
        return new ProfilerToken(instance, sampleName);
    }

    private void RecordSample(string name, double milliseconds)
    {
        if (!profiledSystems.ContainsKey(name))
        {
            profiledSystems[name] = new ProfilerData();
        }
        
        var data = profiledSystems[name];
        data.AddSample(milliseconds);
    }

    public struct ProfilerToken : System.IDisposable
    {
        private PerformanceProfiler profiler;
        private string sampleName;
        private Stopwatch stopwatch;

        public ProfilerToken(PerformanceProfiler profiler, string sampleName)
        {
            this.profiler = profiler;
            this.sampleName = sampleName;
            this.stopwatch = Stopwatch.StartNew();
        }

        public void Dispose()
        {
            if (profiler != null && stopwatch != null)
            {
                stopwatch.Stop();
                double ms = stopwatch.Elapsed.TotalMilliseconds;
                profiler.RecordSample(sampleName, ms);
            }
        }
    }

    private class ProfilerData
    {
        private List&lt;double&gt; samples = new List&lt;double&gt;(60);
        public double PeakMs { get; private set; }
        public int CallCount { get; private set; }
        
        public double AverageMs
        {
            get
            {
                if (samples.Count == 0) return 0;
                double sum = 0;
                foreach (var sample in samples)
                    sum += sample;
                return sum / samples.Count;
            }
        }

        public void AddSample(double milliseconds)
        {
            samples.Add(milliseconds);
            PeakMs = Mathf.Max((float)PeakMs, (float)milliseconds);
            CallCount++;
            
            // Keep only last 60 samples for rolling average
            if (samples.Count > 60)
                samples.RemoveAt(0);
        }
    }
}

// Usage Example:
// using (PerformanceProfiler.BeginSample("CorruptionUpdate"))
// {
//     UpdateCorruptionSpread();
// }</code></pre>
            </details>
        </section>

        <section class="team-section">
            <h2>Development Team</h2>
            <div class="team-grid">
                <div class="team-member">
                    <h3>Gavin Schmidt</h3>
                    <p class="role">Gameplay Engineer & Technical Mentor</p>
                    <p>Performance optimization, corruption systems, character controller, technical leadership, bug tracking</p>
                </div>
                <div class="team-member">
                    <h3>Ghost Knights Team</h3>
                    <p class="role">Development Team</p>
                    <p>Level design, environmental art, audio design, narrative design, gameplay programming</p>
                </div>
            </div>
        </section>

        <section class="reflection-section">
            <h2>Developer Reflection</h2>
            <div class="reflection-content">
                <p>
                    Working on PATCHED as both a gameplay engineer and technical mentor was an incredibly rewarding experience. 
                    The dual responsibility of implementing core systems while guiding team members through their own 
                    technical challenges pushed me to communicate complex concepts clearly and think deeply about code 
                    architecture.
                </p>
                <p>
                    The performance optimization work was particularly satisfying. Using custom profiling tools, I 
                    identified that our corruption shader was causing significant GPU bottlenecks, and our patch 
                    collection spawning was fragmenting memory. Through targeted refactoring‚Äîimplementing object pooling, 
                    optimizing shader calculations, and restructuring our material systems‚Äîwe achieved a 35% memory 
                    reduction and maintained 60 FPS even in the most visually intensive corruption zones.
                </p>
                <p>
                    Implementing the bug tracking system transformed our workflow. By establishing clear reproduction 
                    steps, priority levels, and ownership tracking, we reduced average issue resolution time by 45%. 
                    More importantly, it became a teaching tool‚Äîwhen team members submitted bugs, we'd walk through 
                    the debugging process together, building their troubleshooting skills.
                </p>
                <p>
                    The mentorship aspect taught me as much as the technical work. Running weekly code review sessions 
                    and pair programming workshops forced me to articulate my decision-making process and consider 
                    alternative approaches. Watching team members grow from struggling with basic debugging to 
                    independently optimizing their own systems was incredibly fulfilling.
                </p>
                <p>
                    PATCHED represents not just a technical achievement, but a collaborative success. The horror 
                    platformer genre demands responsive controls and atmospheric consistency‚Äîrequirements that directly 
                    conflicted with our initial performance issues. Overcoming these challenges through systematic 
                    profiling, team education, and iterative optimization demonstrated the power of combining technical 
                    expertise with effective mentorship.
                </p>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2026 Gavin Schmidt. All Rights Reserved.</p>
        <nav class="footer-nav">
            <a href="index.html">Home</a>
            <a href="projects.html">Projects</a>
            <a href="experience.html">Work</a>
            <a href="music.html">Music</a>
            <a href="index.html#contact">Contact</a>
            <a href="resume.html">Resume</a>
        </nav>
    </footer>

    <script>
        // Mobile navigation
        const hamburger = document.getElementById('hamburger-menu');
        const mainNav = document.getElementById('main-nav');
        
        hamburger.addEventListener('click', () => {
            mainNav.classList.toggle('active');
            hamburger.classList.toggle('active');
            
            // Create overlay if it doesn't exist
            if (!document.querySelector('.nav-overlay')) {
                const overlay = document.createElement('div');
                overlay.className = 'nav-overlay';
                document.body.appendChild(overlay);
                
                overlay.addEventListener('click', () => {
                    mainNav.classList.remove('active');
                    hamburger.classList.remove('active');
                    overlay.remove();
                });
            } else {
                document.querySelector('.nav-overlay').remove();
            }
        });

        // Close menu on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && mainNav.classList.contains('active')) {
                mainNav.classList.remove('active');
                hamburger.classList.remove('active');
                const overlay = document.querySelector('.nav-overlay');
                if (overlay) overlay.remove();
            }
        });

        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const headerOffset = 80;
                    const elementPosition = target.getBoundingClientRect().top;
                    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });
    </script>
</body>
</html>
