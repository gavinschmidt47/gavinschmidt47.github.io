<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C47TXLXECX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-C47TXLXECX');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Gavin Schmidt's Portfolio - Fearosis</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
</head>
<body>
    <header>
        <h1>Gavin Schmidt's Portfolio</h1>

        <nav>
            <ul class="nav-menu" id="nav-menu">
                <li><a href="#about">Home</a></li>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="music.html">Music</a></li>
                <li><a href="#contact">Contact</a></li>
                <li><a href="resume.html" target="_blank">Resume</a></li>
            </ul>
        </nav>

    </header>
    <main class="fearosis-showcase">
    <div class="hero-section">
        <img src="Media/Pieces/Fearosis/Fearosis Logo.png" alt="Fearosis Logo" class="fearosis-logo">
        <h1 class="project-title">Fearosis:  Monster Pandemic Simulator</h1>
        <p class="project-tagline">Strategic simulation meets monstrous horror</p>
    </div>

    <img src="Media/Pieces/Fearosis/Fearosis Poster.png" alt="Fearosis Project Poster" class="poster-image">

    <section class="project-overview-section">
        <h2>üéÆ Project Overview</h2>
        <p class="overview-text">
            Fearosis is a strategic simulation game where players design and unleash terrifying monster diseases 
            (like Cult, AI, and Monstrosis) to infect populations.  Inspired by Plague Inc.'s pandemic mechanics 
            but with a monstrous twist, I served as <strong>Lead Programmer</strong> for this Android title, 
            architecting and implementing nearly all game systems. 
        </p>
    </section>

    <section class="key-features-section">
        <h2>‚ö° Technical Highlights</h2>
        <div class="features-grid">
            <div class="feature-card">
                <div class="feature-icon">üß†</div>
                <h3>Stat-Based Simulation</h3>
                <p>Dynamic event system with reactive spread mechanics</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">üå≥</div>
                <h3>Adaptive Upgrade Tree</h3>
                <p>Responds intelligently to player strategies</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">üó∫Ô∏è</div>
                <h3>A* Pathfinding</h3>
                <p>Custom algorithm for disease propagation</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">‚ö°</div>
                <h3>Object Pooling</h3>
                <p>Optimized performance for mobile devices</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">üîí</div>
                <h3>Secure Save System</h3>
                <p>Binary serialization prevents manipulation</p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">üéµ</div>
                <h3>Music Loop System</h3>
                <p>Seamless transitions between intro and loop</p>
            </div>
        </div>
    </section>

    <section class="code-showcase-section">
        <h2>üíª Code Showcase</h2>

        <div class="code-feature">
            <h3>üîí Secure Save System with Binary Serialization</h3>
            <p class="code-description">
                Implemented using MemoryPack for efficient binary serialization, preventing player manipulation 
                of save files. The system handles complex game state including all stats, events, and upgrades.
            </p>
            <div class="code-container">
                <details>
                    <summary>SaveSystem.cs - Binary Save/Load Implementation</summary>
                    <pre><code class="language-csharp">
using UnityEngine;
using System.IO;
using MemoryPack;

public class SaveSystem : MonoBehaviour
{
    private string saveFilePath;

    void Awake()
    {
        saveFilePath = Path.Combine(Application.persistentDataPath, "savefile.dat");
    }

    public void SaveGame(SaveData saveData)
    {
        byte[] bytes = MemoryPackSerializer. Serialize(saveData);
        File.WriteAllBytes(saveFilePath, bytes);
        Debug.Log("Game saved to " + saveFilePath);
    }

    public SaveData LoadGame()
    {
        if (! File.Exists(saveFilePath))
        {
            Debug. LogWarning("Save file not found at " + saveFilePath);
            return null;
        }

        byte[] bytes = File.ReadAllBytes(saveFilePath);
        SaveData saveData = MemoryPackSerializer.Deserialize<SaveData>(bytes);
        Debug.Log("Game loaded from " + saveFilePath);
        return saveData;
    }
}
                    </code></pre>
                </details>
            </div>
        </div>

        <div class="code-feature">
            <h3>üéµ Advanced Music Looper with Seamless Transitions</h3>
            <p class="code-description">
                Dynamically transitions from intro to looping music with precise timing control. Uses events 
                to notify other systems when the main loop starts, allowing for volume control synchronization.
            </p>
            <div class="code-container">
                <details>
                    <summary>MusicLooper.cs - Dynamic Audio Transition System</summary>
                    <pre><code class="language-csharp">
using System;
using UnityEngine;
using UnityEngine.Audio;

public class MusicLooper : MonoBehaviour
{
    public AudioClip introClip;
    public AudioClip mainClip;
    public AudioMixerGroup audioMixerGroup;
    public float transitionTime = 0.1f;

    public event Action<AudioSource> OnMainLoopStarted;

    private AudioSource audioSource;
    private AudioSource mainAudioSource;
    private bool mainStarted = false;

    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        audioSource.outputAudioMixerGroup = audioMixerGroup;
        audioSource.clip = introClip;
        audioSource.loop = false;
        audioSource.Play();
    }

    void Update()
    {
        float timeRemaining = audioSource.clip. length - audioSource.time;
        if (! mainStarted && timeRemaining <= transitionTime)
        {
            mainAudioSource = gameObject.AddComponent<AudioSource>();
            mainAudioSource.volume = audioSource.volume;
            mainAudioSource.outputAudioMixerGroup = audioMixerGroup;
            mainAudioSource.clip = mainClip;
            mainAudioSource.loop = true;
            mainAudioSource.Play();
            mainStarted = true;
            OnMainLoopStarted?. Invoke(mainAudioSource);
        }
    }
}
                    </code></pre>
                </details>
            </div>
        </div>

        <div class="code-feature">
            <h3>üß† Parent Point Class (Simulation Foundation)</h3>
            <p class="code-description">
                Base class for all game stats (Fear, Notoriety, Prejudice, Pain). Tracks points from multiple 
                sources with event-based modifiers for dynamic gameplay. 
            </p>
            <div class="code-container">
                <details>
                    <summary>Point.cs - Stat System Architecture</summary>
                    <pre><code class="language-csharp">
using UnityEngine;
using UnityEngine.Events;

public class Point : MonoBehaviour
{
    //Total of all points
    public int numPointsTotal;
    //Starting points from defining trait
    public int numPointsStart;
    //Points gained today
    public int numPointsGainedToday;

    //Points from modifiable sources
    public int numPointsFromBlood;
    public int numPointsFromPhysical;
    public int numPointsFromBehavior;
    public int numPointsFromPsychological;

    //Event modifiers
    public float eventStatModifier;
    public float eventBloodModifier;
    public float eventPhysicalModifier;
    public float eventBehaviorModifier;
    public float eventPsychologicalModifier;

    void Start()
    {
        numPointsFromBlood = 0;
        numPointsFromPhysical = 0;
        numPointsFromBehavior = 0;
        numPointsFromPsychological = 0;

        eventStatModifier = 1.0f;
        eventBloodModifier = 1.0f;
        eventPhysicalModifier = 1.0f;
        eventBehaviorModifier = 1.0f;
        eventPsychologicalModifier = 1.0f;

        numPointsTotal = numPointsStart;
    }

    public virtual void GainPoints(int pointsToGain, string source)
    {
        numPointsGainedToday += pointsToGain;

        if (pointsToGain >= 0)
        {
            //Add to source-specific points
            switch (source)
            {
                case "Blood":
                    numPointsFromBlood += pointsToGain;
                    break;
                case "Physical": 
                    numPointsFromPhysical += pointsToGain;
                    break;
                case "Behavior":
                    numPointsFromBehavior += pointsToGain;
                    break;
                case "Psychological":
                    numPointsFromPsychological += pointsToGain;
                    break;
                default:
                    Debug.Log("Error: Invalid source for points.");
                    break;
            }
        }
    }

    //Math to calculate total points with modifiers
    public int GetTotalPoints()
    {
        numPointsTotal = Mathf.RoundToInt((numPointsFromBlood * eventBloodModifier
        + numPointsFromPhysical * eventPhysicalModifier
        + numPointsFromBehavior * eventBehaviorModifier 
        + numPointsFromPsychological * eventPsychologicalModifier) 
        * eventStatModifier) + numPointsStart;
        return numPointsTotal;
    }
}
                    </code></pre>
                </details>
            </div>
        </div>

        <div class="code-feature">
            <h3>üé≤ Day Handler - Simulation Engine</h3>
            <p class="code-description">
                Core gameplay loop that calculates infection spread, hunter spawning, and influence gain based 
                on player stats. Uses Unity Events for extensibility.
            </p>
            <div class="code-container">
                <details>
                    <summary>DayHandler.cs - Game Loop Logic</summary>
                    <pre><code class="language-csharp">
using UnityEngine;
using UnityEngine.Events;

public class DayHandler : MonoBehaviour
{
    //Infection rate modifier
    public float infectionRate;
    public float populationInfluenceModifier;
    public int hunterThreshold;
    public int huntersPerThreshold;
    public int painThreshold;

    //References to other scripts
    private Fear fearScript;
    private Notoriety notorietyScript;
    private Prejudice prejudiceScript;
    private Pain painScript;
    private Influence influenceScript;
    private FullGameStats fullGameStatsScript;

    //Unity event on day start
    public UnityEvent dayStartEvent = new UnityEvent();

    public void OnNextDay()
    {
        //Get stats
        int numFear = fearScript.GetTotalPoints();
        int numNotoriety = notorietyScript.GetTotalPoints();
        int numPrejudice = prejudiceScript.GetTotalPoints();
        int numPain = painScript. GetTotalPoints();
        int instability = Mathf. Abs(numNotoriety - numPrejudice);

        //Calculate new infections
        numInfectedToGain += Mathf.RoundToInt(numFear + Random.Range(
            Mathf.Max(numFear - instability, 0), numFear + instability) * infectionRate);

        //Update full game stats script
        fullGameStatsScript. AddInfected(numInfectedToGain);

        //Calculate hunter kills
        fullGameStatsScript.KillInfected(fullGameStatsScript.hunters);

        //Calculate pain kills
        if (numPain >= painThreshold)
        {
            fullGameStatsScript.KillInfected(numPain - painThreshold);
        }

        //Influence logic
        int populationModifiedInfectionInfluence = 
            Mathf.Max(Mathf.RoundToInt(numInfectedToGain / populationInfluenceModifier), 1);
        numInfluenceToGain = Mathf.Max(Mathf.RoundToInt(numPain*. 67f + 
            populationModifiedInfectionInfluence + Mathf.Max(numNotoriety*.50f, 1)), 5);
        influenceScript.influencePoints += numInfluenceToGain;

        //Hunter logic
        if (instability > hunterThreshold)
        {
            int numHuntersToAdd = instability * huntersPerThreshold;
            fullGameStatsScript.hunters += numHuntersToAdd;
        }

        //Call day start event
        dayStartEvent. Invoke();
    }
}
                    </code></pre>
                </details>
            </div>
        </div>

        <div class="code-feature">
            <h3>üå≥ Dynamic Upgrade System</h3>
            <p class="code-description">
                Event-driven upgrade tree that unlocks nodes based on prerequisites. Uses C# events for clean 
                dependency management between upgrades.
            </p>
            <div class="code-container">
                <details>
                    <summary>Upgrade.cs - Prerequisite & Event System</summary>
                    <pre><code class="language-csharp">
using UnityEngine;
using System;

public class Upgrade : MonoBehaviour
{
    public string upgradeName;
    public string upgradeDescription;
    public int upgradeCost;
    public bool isFirstUpgrade;

    [Header("Add prerequisite upgrades (if applicable)")]
    public GameObject[] prerequisiteUpgrades;
    public bool isPurchased = false;
    public event Action upgradePurchased;
    public event Action upgradeUnlocked;

    [Header("Add value you wish to buff")]
    [SerializeField] private int fearBuff;
    [SerializeField] private int notorietyBuff;
    [SerializeField] private int prejudiceBuff;
    [SerializeField] private int painBuff;

    private enum SourceType { Blood, Physical, Behavior, Psychological };
    [SerializeField] private SourceType source;

    void Awake()
    {
        if (prerequisiteUpgrades. Length > 0)
        {
            foreach (GameObject prereq in prerequisiteUpgrades)
            {
                Upgrade prereqStatus = prereq.GetComponent<Upgrade>();
                prereqStatus.upgradePurchased += this.CheckPrerequisites;
            }
        }
    }

    public void Purchase()
    {
        if (!isPurchased && influenceScript.influencePoints >= upgradeCost)
        {
            influenceScript.influencePoints -= upgradeCost;
            isPurchased = true;
            upgradePurchased?.Invoke();
            ApplyUpgrade();
        }
    }

    public void CheckPrerequisites() 
    {
        bool unlockable = true;
        if (prerequisiteUpgrades != null)
        {
            foreach (GameObject prereq in prerequisiteUpgrades) 
            {
                Upgrade prereqStatus = prereq.GetComponent<Upgrade>();
                if (prereqStatus.isPurchased == false)
                {
                    unlockable = false;
                    break;
                }
            }
        }
        if (unlockable) upgradeUnlocked?.Invoke();
    }
}
                    </code></pre>
                </details>
            </div>
        </div>

        <div class="code-feature">
            <h3>üó∫Ô∏è A* Pathfinding for Disease Spread</h3>
            <p class="code-description">
                Custom A* implementation using Poisson Disc Sampling for grid generation.  Optimized for mobile 
                with efficient neighbor lookups and path retracing.
            </p>
            <div class="code-container">
                <details>
                    <summary>AStar.cs - Pathfinding Algorithm</summary>
                    <pre><code class="language-csharp">
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class AStar :  MonoBehaviour
{
    private PoissonDiscGrid grid = PoissonDiscGrid.Instance;
    public int maxSearchIterations = 1000;

    public List<Node> FindPath(Node startNode, Node targetNode)
    {
        if (! startNode.valid || !targetNode.valid) return null;

        targetNode.MakeTargetNode(startNode);
        startNode.MakeStartNode(targetNode);

        //Initialize open and checked sets
        List<Node> openSet = new List<Node>();
        HashSet<Node> checkedSet = new HashSet<Node>();
        openSet.Add(startNode);

        int iterations = 0;

        //fCost = gCost(Distance from start) + hCost (Distance from target)
        while (openSet.Count > 0 && iterations < maxSearchIterations)
        {
            iterations++;

            //Find node in openSet with lowest fCost
            Node currentNode = openSet.OrderBy(n => n.fCost).ThenBy(n => n.hCost).First();

            //Move currentNode from openSet to checkedSet
            openSet.Remove(currentNode);
            checkedSet.Add(currentNode);

            //End condition - reached target
            if (currentNode == targetNode) return RetracePath(startNode, currentNode);

            //Check each neighbor of currentNode
            List<Node> neighbors = grid.GetNeighbors(currentNode);
            foreach (Node neighbor in neighbors)
            {
                if (! neighbor.valid || checkedSet.Contains(neighbor)) continue;

                //Calculate tentative gCost for this path to neighbor
                float tentativeGCost = currentNode. gCost + 
                    (currentNode.worldPosition - neighbor.worldPosition).magnitude;

                //If neighbor is not in openSet or we found a better path
                if (!openSet.Contains(neighbor) || tentativeGCost < neighbor.gCost)
                {
                    //Update neighbor with better path
                    neighbor.GiveReferences(currentNode, targetNode);
                    neighbor.gCost = tentativeGCost;

                    if (!openSet.Contains(neighbor)) openSet.Add(neighbor);
                }
            }
        }
        return null; //No path found
    }
    
    private List<Node> RetracePath(Node startNode, Node endNode)
    {
        List<Node> path = new List<Node>();
        Node currentNode = endNode;

        while (currentNode != startNode)
        {
            path. Add(currentNode);
            if (currentNode.parent == null) break;
            currentNode = currentNode.parent;
        }
        
        path.Add(startNode);
        path.Reverse();
        return path;
    }
}
                    </code></pre>
                </details>
            </div>
        </div>
    </section>

    <section class="team-section">
        <h2>üë• Team Credits</h2>
        <div class="team-grid">
            <div class="team-member">
                <div class="team-icon">üé¨</div>
                <strong>Jadyn Englett</strong>
                <span>Producer</span>
            </div>
            <div class="team-member">
                <div class="team-icon">üé®</div>
                <strong>Olin Britt-Tores</strong>
                <span>Character & Map Art</span>
            </div>
            <div class="team-member">
                <div class="team-icon">üñåÔ∏è</div>
                <strong>Ash Cho Chia Yuen</strong>
                <span>UI Art</span>
            </div>
            <div class="team-member">
                <div class="team-icon">üß©</div>
                <strong>Samuel Drastal</strong>
                <span>Level Design & Camera</span>
            </div>
            <div class="team-member">
                <div class="team-icon">üè∞</div>
                <strong>Wesley Yates</strong>
                <span>Level Design</span>
            </div>
            <div class="team-member">
                <div class="team-icon">‚öñÔ∏è</div>
                <strong>Dylan Hendricks</strong>
                <span>Game Balancing</span>
            </div>
        </div>
    </section>

    <section class="reflection-section">
        <h2>üí≠ Developer Reflection</h2>
        <blockquote>
            Working on Fearosis challenged me to create complex systems that feel organic and responsive. 
            Seeing players strategize with our monstrous diseases validated our approach to blending 
            simulation depth with emergent gameplay! 
        </blockquote>
    </section>
</main>
</body>
</html>