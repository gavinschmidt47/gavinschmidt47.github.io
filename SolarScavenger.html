<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C47TXLXECX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-C47TXLXECX');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Gavin Schmidt's Portfolio - Solar Scavenger</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
</head>
<body class="solarscavenger-page">
    
    <!-- Static Background -->
    <div class="static-background"></div>
    
    <!-- Modern Header -->
    <header class="main-header">
        <div class="header-container">
            <div class="header-brand">
                <a href="index.html" class="brand-link">
                    <span class="brand-name">Gavin Schmidt</span>
                    <span class="brand-subtitle">Game Designer, Composer, Programmer, and Software Engineer</span>
                </a>
            </div>

            <button class="hamburger" id="hamburger-menu" aria-label="Toggle navigation menu">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>

            <nav class="main-nav" id="main-nav">
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a href="index.html" class="nav-link">
                            <span class="nav-icon">üè†</span>
                            <span class="nav-text">Home</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="projects.html" class="nav-link">
                            <span class="nav-icon">üéÆ</span>
                            <span class="nav-text">Projects</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="experience.html" class="nav-link">
                            <span class="nav-icon">üíº</span>
                            <span class="nav-text">Work</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="music.html" class="nav-link">
                            <span class="nav-icon">üéµ</span>
                            <span class="nav-text">Music</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="index.html#contact" class="nav-link">
                            <span class="nav-icon">üìß</span>
                            <span class="nav-text">Contact</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="resume.html" class="nav-link nav-link-highlight">
                            <span class="nav-icon">üìÑ</span>
                            <span class="nav-text">Resume</span>
                        </a>
                    </li>
                </ul>
            </nav>
        </div>
    </header>
    <main class="solarscavenger-showcase">
        <div class="hero-section">
            <div class="jam-badge">
                <span class="badge-text">üöÄ FIEA Game Jam 2026</span>
            </div>
            <img src="Media/Pieces/SolarScavenger/SS_Title.png" alt="Solar Scavenger" class="reactiveskies-logo">
            <p class="project-tagline">Escape the Dying Star</p>
            <div class="jam-info">
                <span class="jam-detail">üåü Space Survival</span>
                <span class="jam-separator">‚Ä¢</span>
                <span class="jam-detail">‚è±Ô∏è Built in 48 Hours</span>
                <span class="jam-separator">‚Ä¢</span>
                <span class="jam-detail">üéÆ Gameplay Engineer & Composer</span>
            </div>
        </div>

        <!-- Gameplay Video Showcase -->
        <section class="gameplay-video-section">
            <div class="video-wrapper">
                <h2>Gameplay Preview</h2>
                <div class="video-container-gameplay">
                    <video autoplay loop muted playsinline>
                        <source src="Media/Pieces/SolarScavenger/gameplay.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                </div>
                <p class="video-caption">Watch the frantic escape from Icarus-XIII as scavengers pursue through procedurally generated sectors</p>
            </div>
        </section>

        <section class="project-overview-section">
            <h2>Game Jam Experience</h2>
            <p class="overview-text">
                Solar Scavenger was created for the <strong>FIEA Game Jam 2026</strong>, an intense 48-hour 
                development challenge where our team of 4 built a complete space survival experience from scratch. 
                The game centers around a desperate escape from the dying Icarus-XIII star, with players navigating 
                through procedurally generated space sectors while being pursued by hostile scavengers and pirates.
            </p>
            <p class="overview-text">
                One of the most memorable aspects of this jam was the incredible support from the judges. Their 
                constructive feedback during playtesting helped us refine our momentum-based controls and balance 
                the resource management systems. Their insights on pacing and difficulty scaling were invaluable 
                in making the final hours of development count. The judges' enthusiasm for our procedural generation 
                approach and dynamic difficulty systems validated our technical decisions and gave us confidence 
                in the game's potential.
            </p>
            <p class="overview-text">
                As <strong>Gameplay Engineer & Composer</strong>, I designed and implemented the procedural chunk-based 
                generation system, resource management mechanics, and momentum-based controls that define the core 
                gameplay. I also composed the adaptive music system that responds to game state, intensifying as 
                danger increases. The experience taught me the value of modular systems and performance optimization 
                in real-time procedural generation.
            </p>
        </section>

        <section class="gallery-section">
            <h2>Visual Showcase</h2>
            <div class="gallery-grid">
                <div class="gallery-item">
                    <img src="Media/Pieces/SolarScavenger/SS_Explore.gif" alt="Sector Exploration">
                    <p class="gallery-caption">Deep Space Exploration</p>
                </div>
                <div class="gallery-item">
                    <img src="Media/Pieces/SolarScavenger/SS_Enemy1.gif" alt="Scavenger Drone">
                    <p class="gallery-caption">Scavenger Drone</p>
                </div>
                <div class="gallery-item">
                    <img src="Media/Pieces/SolarScavenger/SS_Enemy2.gif" alt="Belt Dweller">
                    <p class="gallery-caption">Belt Dweller</p>
                </div>
            </div>
        </section>

        <section class="key-features-section">
            <h2>Technical Highlights</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <h3>Procedural Generation</h3>
                    <p>Chunk-based infinite space exploration with seamless loading</p>
                </div>
                <div class="feature-card">
                    <h3>Object Pooling</h3>
                    <p>Performance-optimized enemy and resource spawning system</p>
                </div>
                <div class="feature-card">
                    <h3>Resource Management</h3>
                    <p>Strategic scavenging mechanics with fuel and supplies</p>
                </div>
                <div class="feature-card">
                    <h3>Momentum Controls</h3>
                    <p>Physics-based movement for realistic space navigation</p>
                </div>
                <div class="feature-card">
                    <h3>Dynamic Difficulty</h3>
                    <p>Adaptive challenge scaling responsive to player progress</p>
                </div>
                <div class="feature-card">
                    <h3>Adaptive Systems</h3>
                    <p>Enemy spawn rates adjust based on performance</p>
                </div>
                <div class="feature-card">
                    <h3>Progressive Music</h3>
                    <p>Soundtrack intensity responds to danger levels</p>
                </div>
                <div class="feature-card">
                    <h3>Dynamic Lighting</h3>
                    <p>Visual atmosphere tied to star's dying state</p>
                </div>
            </div>
        </section>

        <section class="learning-section">
            <h2>Development Insights</h2>
            <div class="learning-grid">
                <div class="learning-card">
                    <h3>Procedural Generation</h3>
                    <p>
                        <strong>What I Learned:</strong> Building a chunk-based procedural generation system taught 
                        me about spatial hashing, efficient neighbor lookups, and seamless world streaming. The 
                        challenge was ensuring smooth performance while generating infinite space in real-time. 
                        Implementing adaptive chunk loading based on player location significantly improved the 
                        experience.
                    </p>
                </div>
                <div class="learning-card">
                    <h3>Performance Optimization</h3>
                    <p>
                        <strong>What I Learned:</strong> Object pooling became essential for maintaining 60fps 
                        with hundreds of asteroids, enemies, and collectibles. Rather than instantiating/destroying 
                        objects constantly, we reused them strategically. This pattern reduced garbage collection 
                        and kept the game buttery smooth even in intense combat scenarios.
                    </p>
                </div>
                <div class="learning-card">
                    <h3>Momentum-Based Physics</h3>
                    <p>
                        <strong>What I Learned:</strong> Creating satisfying momentum controls requires careful 
                        tuning and tweaking. These, of course, being things we had very little time for in a 
                        48-hour jam. This helped me learn to prioritize core mechanics and iterate quickly on 
                        feel. Although realism was a goal, player enjoyment took precedence, leading to adjustments 
                        that balanced authenticity with fun. The result was a control scheme that felt weighty and 
                        responsive, enhancing the tension of escaping the star.
                    </p>
                </div>
                <div class="learning-card">
                    <h3>Adaptive Game Systems</h3>
                    <p>
                        <strong>What I Learned:</strong> Dynamic difficulty scaling based on player performance 
                        created a more engaging experience. Tracking metrics like distance traveled, resources collected, 
                        and damage taken allowed us to adjust spawn rates and enemy behavior in real-time, keeping 
                        players immersed in the ever-changing and dynamic game environment.
                    </p>
                </div>
            </div>
        </section>

        <section class="code-showcase-section">
            <h2>Code Showcase</h2>

            <div class="code-feature">
                <h3>Procedural Sector Generation System</h3>
                <p class="code-description">
                    Developed an infinite procedural world generation system that creates sectors on-demand based on 
                    player position. The system calculates distance from the sun to determine resource density and 
                    threat levels, creating a natural difficulty curve. Sectors are tracked in a dictionary for 
                    efficient retrieval and memory management.
                </p>
                <div class="code-container">
                    <details>
                        <summary>SectorFactory.cs - On-Demand World Generation</summary>
                        <pre><code class="language-csharp">
using UnityEngine;

public class SectorFactory : MonoBehaviour
{
    public static SectorFactory Instance { get; private set; }
    const int SectorSize = 100;

    public Vector2Int sunPosition;
    public int sunDistance = 1000;
    public GameObject sectorPrefab;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Randomize sun position for replayability
        switch(UnityEngine.Random.Range(0,4))
        {
            case 0: sunPosition = Vector2Int.up; break;
            case 1: sunPosition = Vector2Int.right; break;
            case 2: sunPosition = Vector2Int.down; break;
            case 3: sunPosition = Vector2Int.left; break;
        }
    }

    // Called when a new sector needs to be generated
    public Sector GenerateSector(Vector2Int sectorGridPosition)
    {
        // Instantiate sector at grid-based world position
        GameObject sectorObject = Instantiate(
            sectorPrefab, 
            new Vector3(sectorGridPosition.x * SectorSize, sectorGridPosition.y * SectorSize, 0f), 
            Quaternion.identity
        );
        sectorObject.transform.SetParent(transform);
        sectorObject.name = $"Sector({sectorGridPosition.x},{sectorGridPosition.y})";

        // Calculate distance from sun for difficulty scaling
        float distanceFromSun = Vector2.Distance(
            sectorGridPosition * 100 * sunPosition, 
            sunPosition * sunDistance
        );
        
        Sector sector = sectorObject.GetComponent&lt;Sector&gt;();
        sector.ReceivePackage(new FactoryPackaging(distanceFromSun, sectorGridPosition));

        // Register with sector manager
        SectorManager.Instance.StoreNewSector(sectorGridPosition, ref sector);

        // Subscribe to player enter event for dynamic loading
        sector.OnPlayerEnter += (s) => { 
            SectorManager.Instance.ShiftPlayerSector(sectorGridPosition); 
        };
        
        return sector;
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>Dynamic Sector Loading with Memory Management</h3>
                <p class="code-description">
                    Implemented a sliding window algorithm that loads/unloads sectors as the player moves through 
                    the world. This system maintains a 5x5 grid of active sectors around the player, disabling 
                    sectors outside the range and reactivating cached sectors when revisiting areas. This approach 
                    enables infinite world exploration without performance degradation.
                </p>
                <div class="code-container">
                    <details>
                        <summary>SectorManager.cs - Efficient World Streaming</summary>
                        <pre><code class="language-csharp">
public class SectorManager : MonoBehaviour
{
    public static SectorManager Instance { get; private set; }

    const int MaxSectors = 25;  // 5x5 grid
    const int midPoint = 2;      // Center of grid

    private Sector[][] currLoadedSectors;
    private Vector2Int playerSectorPosition;
    private Dictionary&lt;Vector2Int, Sector&gt; prevLoadedSectors;  // Cached sectors

    public void ShiftPlayerSector(Vector2Int newMidSectorGridPosition)
    {
        Vector2Int shiftdir = newMidSectorGridPosition - playerSectorPosition;

        // Create new sector array
        Sector[][] tempSectors = new Sector[5][];
        for (int i = 0; i &lt; tempSectors.Length; i++)
            tempSectors[i] = new Sector[5];

        // Shift existing sectors in opposite direction of player movement
        for (int i = 0; i &lt; currLoadedSectors.Length; i++)
        {
            for (int j = 0; j &lt; currLoadedSectors[i].Length; j++)
            {
                int x = i - shiftdir.x;
                int y = j - shiftdir.y;

                if (x &gt;= 0 &amp;&amp; x &lt; tempSectors.Length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; tempSectors[x].Length)
                {
                    // Sector stays in range, keep it active
                    tempSectors[x][y] = currLoadedSectors[i][j];
                }
                else if (currLoadedSectors[i][j] != null)
                {
                    // Sector leaving range, disable but keep cached
                    currLoadedSectors[i][j].gameObject.SetActive(false);
                }
            }
        }

        currLoadedSectors = tempSectors;

        // Load new sectors in direction of movement
        Vector2Int newSectorGridOffset;
        Vector2Int sectorGridPosToBeLoaded;

        switch (shiftdir)
        {
            case var v when v.x &gt; 0:  // Moving right
                for (int i = 0; i &lt; currLoadedSectors[0].Length; i++)
                {
                    newSectorGridOffset = new Vector2Int(2, i - midPoint);
                    sectorGridPosToBeLoaded = newMidSectorGridPosition + newSectorGridOffset;
                    
                    // Try to retrieve cached sector, otherwise generate new
                    Sector sector = GetPreviousSector(sectorGridPosToBeLoaded);
                    if (sector == null)
                        sector = SectorFactory.Instance.GenerateSector(sectorGridPosToBeLoaded);
                    else
                        sector.gameObject.SetActive(true);
                    
                    currLoadedSectors[currLoadedSectors.Length - 1][i] = sector;
                }
                break;
            // ... similar cases for left, up, down
        }

        playerSectorPosition = newMidSectorGridPosition;
    }

    public void StoreNewSector(Vector2Int sectorPosition, ref Sector sector)
    {
        prevLoadedSectors[sectorPosition] = sector;
    }

    public Sector GetPreviousSector(Vector2Int sectorPosition)
    {
        return prevLoadedSectors.GetValueOrDefault(sectorPosition);
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>State Machine AI with Inheritance Hierarchy</h3>
                <p class="code-description">
                    Architected a flexible enemy AI system using a state machine pattern with virtual methods for 
                    behavior customization. The BaseEnemy class handles common logic (pursuit, attacking), while 
                    derived classes override specific behaviors. This OOP design enabled rapid creation of diverse 
                    enemy types with unique mechanics.
                </p>
                <div class="code-container">
                    <details>
                        <summary>BaseEnemy.cs - Extensible AI Foundation</summary>
                        <pre><code class="language-csharp">
public class BaseEnemy : Asteroid
{
    protected Player player;
    protected Rigidbody2D rb;

    protected enum EnemyState
    {
        DORMANT,     // Passive behavior when player is far
        PURSUIT,     // Chase player
        ATTACK1,     // Close-range attack
        ATTACK2,     // Mid-range attack
        ATTACK3      // Special attack
    }
    protected EnemyState currentState;

    public float forwardSpeed = 0.25f;
    public float forwardSpeedLimit = 6f;
    public float steerSpeed = 2f;

    public float pursuitDistance = 15f;
    public float attack1Distance = 3f;

    void Update()
    {
        switch(currentState)
        {
            case EnemyState.DORMANT:
                DormantTick();
                break;
            case EnemyState.PURSUIT:
                PursuitTick();
                break;
            case EnemyState.ATTACK1:
                Attack1Tick();
                break;
            // ... other states
        }
    }

    protected virtual void DormantTick()
    {
        if(Vector2.Distance(player.transform.position, transform.position) &lt;= pursuitDistance)
            currentState = EnemyState.PURSUIT;
    }

    protected virtual void PursuitTick()
    {
        if(Vector2.Distance(player.transform.position, transform.position) &gt; pursuitDistance)
            currentState = EnemyState.DORMANT;
        else if(Vector2.Distance(player.transform.position, transform.position) &lt;= attack1Distance)
            currentState = EnemyState.ATTACK1;
        else
        {
            // Navigate toward player
            Vector2 wish = (player.transform.position - transform.position).normalized;
            TurnTo(wish, 0.1f);

            if(rb.linearVelocity.magnitude &lt;= forwardSpeedLimit)
                rb.AddForce(GetForwardV() * forwardSpeed);
        }
    }

    protected virtual bool TurnTo(Vector2 wish, float threshold=0.05f)
    {
        Vector2 shipDir = GetForwardV();
        float angle = Mathf.Atan2(shipDir.y, shipDir.x) - Mathf.Atan2(wish.y, wish.x);

        // Normalize angle to -œÄ to œÄ
        if (angle &gt; Mathf.PI)        angle -= 2f * Mathf.PI;
        else if (angle &lt;= -Mathf.PI) angle += 2f * Mathf.PI;

        if (Mathf.Abs(angle) &gt; threshold)
        {
            int dir = angle &gt; 0 ? 1 : -1;
            rb.angularVelocity = dir * steerSpeed * 50f;
            return true;
        }
        
        rb.angularVelocity = 0;
        return false;
    }
}
                        </code></pre>
                    </details>
                    <details>
                        <summary>Scavenger.cs - Sun-Fleeing Enemy Behavior</summary>
                        <pre><code class="language-csharp">
public class Scavenger : BaseEnemy
{
    Vector2Int sunPosition;
    public float dormantSpeedLimit = 4f;

    protected override void subStart()
    {
        sunPosition = SectorFactory.Instance.sunPosition;
    }

    // Override dormant behavior to flee from sun
    protected override void DormantTick()
    {
        if(Vector2.Distance(player.transform.position, transform.position) &lt;= pursuitDistance)
            currentState = EnemyState.PURSUIT;
        else
        {
            // Flee away from sun when not pursuing player
            TurnTo(-sunPosition);

            if(rb.linearVelocity.magnitude &lt;= dormantSpeedLimit)
                rb.AddForce(GetForwardV() * forwardSpeed);
        }
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>Predictive Targeting AI System</h3>
                <p class="code-description">
                    Implemented advanced AI targeting that predicts player movement based on velocity and distance. 
                    The BeltDweller enemy calculates where the player will be when the projectile arrives, creating 
                    challenging combat encounters that require evasive maneuvering rather than simple dodging.
                </p>
                <div class="code-container">
                    <details>
                        <summary>BeltDweller.cs - Predictive Harpoon Targeting</summary>
                        <pre><code class="language-csharp">
public class BeltDweller : BaseEnemy
{
    public GameObject harpoon;

    protected override void PursuitTick()
    {
        float distance = Vector2.Distance(player.transform.position, transform.position);
        
        if(distance &gt; pursuitDistance)
        {
            currentState = EnemyState.DORMANT;
            GetComponent&lt;Rigidbody2D&gt;().angularVelocity = 0;
        }
        else if(distance &lt;= attack2Distance)
        {
            currentState = EnemyState.ATTACK2;
        }
        else
        {
            // PREDICTIVE TARGETING: Calculate where player will be
            // distance/30f estimates projectile travel time
            Vector2 predict = (Vector2)player.transform.position + 
                             (player.GetComponent&lt;Rigidbody2D&gt;().linearVelocity * distance/30f);
            
            Vector2 wish = (predict - (Vector2)transform.position).normalized;
            bool turning = TurnTo(wish);
            
            // Only fire when aimed at predicted position
            if(!turning &amp;&amp; lastAttack1 + attack1Cooldown &lt; Time.time)
                currentState = EnemyState.ATTACK1;
        }
    }

    protected override void Attack1Tick()
    {
        if(lastAttack1 + attack1Cooldown &lt; Time.time)
        {
            // Fire harpoon at predicted position
            GameObject newHarp = Instantiate(harpoon);
            newHarp.transform.position = transform.position;
            newHarp.transform.eulerAngles = transform.eulerAngles;
            newHarp.GetComponent&lt;Rigidbody2D&gt;().AddForce(
                GetForwardV() * newHarp.GetComponent&lt;Harpoon&gt;().impulse
            );

            lastAttack1 = Time.time;
        }
        
        currentState = EnemyState.PURSUIT;
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>Physics-Based Player Movement System</h3>
                <p class="code-description">
                    Created a momentum-based spaceship control system with three movement states (idle, normal thrust, 
                    boost). The system features velocity limiting, resource management (fuel tank), and health-drain 
                    mechanics that force strategic movement decisions. Movement feels weighty and realistic while 
                    remaining responsive.
                </p>
                <div class="code-container">
                    <details>
                        <summary>Player.cs - Multi-State Movement System</summary>
                        <pre><code class="language-csharp">
public class Player : MonoBehaviour
{
    Rigidbody2D rb;

    public float startingHealth = 10f;
    float health;
    public float startHealthDrain = 0.1f;  // Cost of movement
    float currHealthDrain;

    public float forwardSpeed = 0.25f;
    public float boostSpeed = 1f;
    public float boostImpulse = 150f;

    public float forwardSpeedLimit = 5f;   // Max normal velocity
    public float boostSpeedLimit = 10f;    // Max boost velocity

    enum Forward { NONE, NORMAL, BOOST }
    Forward forwardState = Forward.NONE;

    public float maxTank = 100f;
    float tank;
    public float thrustCost = 20f;
    public float tankCooldown = 1f;
    float lastThrust = -1f;
    float lastTank = -1f;

    void Update()
    {
        switch(forwardState)
        {
            case Forward.BOOST:
                if(tank &lt;= 0f)
                {
                    forwardState = Forward.NONE;
                    break;
                }

                lastThrust = Time.time;  // Delay tank regeneration

                if(rb.linearVelocity.magnitude &lt;= boostSpeedLimit)
                    rb.AddForce(GetForwardV() * boostSpeed);

                tank = Mathf.Max(tank - thrustDrain, 0f);
                boostSlider.value = tank/maxTank;
                break;

            case Forward.NORMAL: 
                health -= Time.deltaTime * currHealthDrain;  // Movement costs health

                if(rb.linearVelocity.magnitude &lt;= forwardSpeedLimit)
                    rb.AddForce(GetForwardV() * forwardSpeed);
                break;
                
            case Forward.NONE: 
                // Natural momentum decay
                break;
        }

        // Tank regeneration after cooldown
        if(lastTank + tankCooldown &lt;= Time.time)
        {
            tank = Mathf.Min(tank + tankRegen * Time.deltaTime, maxTank);
            boostSlider.value = tank/maxTank;
        }

        // Steering
        if(steer != 0)
            rb.AddTorque(-steer * steerSpeed);

        // Gravity pull from nearby planets
        if(currentPlanet != null)
        {
            Vector2 direction = (currentPlanet.transform.position - transform.position).normalized;
            float distance = Vector2.Distance(transform.position, currentPlanet.transform.position);
            float gravityForce = currentPlanet.gravityStrength / (distance * distance);
            rb.AddForce(direction * gravityForce);
        }
    }

    public void OnForward(InputAction.CallbackContext context)
    {
        forwardState = context.performed ? Forward.NORMAL : Forward.NONE;
    }

    public void OnThrust(InputAction.CallbackContext context)
    {
        if(context.performed &amp;&amp; tank &gt;= thrustCost &amp;&amp; lastThrust + thrustCooldown &lt; Time.time)
        {
            tank -= thrustCost;
            rb.AddForce(GetForwardV() * boostImpulse);  // Instant boost
            lastThrust = Time.time;
            lastTank = Time.time;
        }
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>Upgrade System with Stat Modifications</h3>
                <p class="code-description">
                    Designed a flexible upgrade system that allows players to modify core stats (health, fuel capacity, 
                    health drain rate, weapon cost). Upgrades are purchased at space stations using salvaged resources, 
                    creating a risk/reward loop where players must venture into dangerous sectors to afford improvements.
                </p>
                <div class="code-container">
                    <details>
                        <summary>Player.cs - Dynamic Stat Modification System</summary>
                        <pre><code class="language-csharp">
// Resource management
public List&lt;SalvageItem&gt; salvageInv = new List&lt;SalvageItem&gt;();
public int maxSalvage = 5;

public bool AddSalvage(Salvage add)
{
    if(salvageInv.Count &gt;= maxSalvage) return false;
    salvageInv.Add(add.data);
    salvageText.text = salvageInv.Count + "/" + maxSalvage;
    return true;
}

// Upgrade methods called by shop system
public void DecreaseHealthDrainUpgrade(float amount)
{
    currHealthDrain = Mathf.Max(0f, currHealthDrain - amount);
}

public void IncreaseMaxHealthUpgrade(float amount)
{
    startingHealth += amount;
    health += amount;  // Also heal current health
    healthSlider.value = health/startingHealth;
}

public void IncreaseTankUpgrade(float amount)
{
    maxTank += amount;
    tank += amount;  // Also restore tank
    boostSlider.value = tank/maxTank;
}

public void DecreaseWeaponCostUpgrade(float amount)
{
    weaponCost = Mathf.Max(0f, weaponCost - amount);
}
                        </code></pre>
                    </details>
                    <details>
                        <summary>Station.cs - Salvage Trading System</summary>
                        <pre><code class="language-csharp">
public class Station : MonoBehaviour
{
    void OnTriggerEnter2D(Collider2D other)
    {
        if(other.CompareTag("Player"))
        {
            Debug.Log("Docked at Station!");

            Player pl = other.gameObject.GetComponent&lt;Player&gt;();

            // Calculate total salvage value
            int sale = 0;
            foreach(SalvageItem s in pl.salvageInv)
                sale += s.value;

            // Clear inventory and give credits
            pl.salvageInv.Clear();
            pl.salvageText.text = pl.salvageInv.Count+"/"+pl.maxSalvage;

            GameManager.instance.GiveCredits(sale);

            // Open shop UI
            CanvasController.instance.setShop(true);
            ShopUI shop = CanvasController.instance.shopLayer.GetComponent&lt;ShopUI&gt;();
            shop.enterShop();
        }
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>
        </section>

        <section class="winning-section">
            <h2>The Future: Goblin Candy Studios</h2>
            <div class="win-highlight">
                <p class="win-text">
                    We're incredibly excited to announce that we're continuing development on Solar Scavenger! 
                    The positive reception at FIEA Game Jam 2026 and the encouraging feedback from judges has 
                    inspired us to expand the game into a full release. We've formed <strong>Goblin Candy Studios</strong> 
                    (temporary name!) to take this project to the next level.
                </p>
                <p class="win-text">
                    Our post-jam roadmap includes expanded procedural generation systems, additional enemy types, 
                    a more robust upgrade system for the player's ship, and narrative elements that flesh out the 
                    lore of the dying Icarus-XIII star. We're planning deeper resource management mechanics with 
                    ship customization options and dynamic story events that respond to player choices.
                </p>
                <p class="win-text">
                    The judges' feedback on improving the readability of resource states and enhancing the visual 
                    distinction between enemy types has already influenced our development priorities. We're grateful 
                    for the game jam experience and can't wait to share the expanded version of Solar Scavenger with 
                    the gaming community!
                </p>
            </div>
        </section>

        <section class="team-section">
            <h2>Team Credits</h2>
            <div class="team-grid">
                <div class="team-member">
                    <div class="team-icon">üéÆ</div>
                    <strong>Luke Cullen</strong>
                    <span>Programming</span>
                </div>
                <div class="team-member">
                    <div class="team-icon">üé®</div>
                    <strong>Ash Cho Chia Yuen</strong>
                    <span>Art & UI</span>
                </div>
                <div class="team-member">
                    <div class="team-icon">üñåÔ∏è</div>
                    <strong>Jacob Arbogast</strong>
                    <span>Additional Art Assets</span>
                </div>
            </div>
        </section>

        <section class="reflection-section">
            <h2>Developer Reflection</h2>
            <blockquote>
                Building Solar Scavenger in 48 hours was an exhilarating challenge that pushed our technical 
                skills and creativity to the limit. The procedural generation system became the backbone of 
                the entire experience, and watching infinite space unfold in real-time as players desperately 
                fled the dying star was incredibly rewarding. The judges' enthusiasm and constructive feedback 
                made this jam experience truly special‚Äîthey didn't just evaluate our work, they invested in 
                helping us make it better. Their insights on balancing challenge and accessibility shaped our 
                dynamic difficulty system in ways we hadn't considered. Forming Goblin Candy Studios to continue 
                this project feels like a natural next step, and we're thrilled to take the momentum from this 
                jam and transform Solar Scavenger into something even more ambitious. This game proved that with 
                the right team, tight constraints breed incredible creativity. I can't wait to see where we take 
                this project next!
            </blockquote>
        </section>
    </main>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="footer-container">
            <p class="footer-text">
                ¬© 2026 Gavin Schmidt. All rights reserved.
            </p>
            <div class="footer-links">
                <a href="index.html">Home</a>
                <span class="footer-separator">‚Ä¢</span>
                <a href="projects.html">Projects</a>
                <span class="footer-separator">‚Ä¢</span>
                <a href="music.html">Music</a>
                <span class="footer-separator">‚Ä¢</span>
                <a href="resume.html">Resume</a>
            </div>
        </div>
    </footer>

    <!-- Mobile Menu Script -->
    <script src="header.js"></script>
    <script src="lightbox.js"></script>
</body>
</html>
