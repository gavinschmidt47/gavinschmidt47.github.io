<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C47TXLXECX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-C47TXLXECX');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Gavin Schmidt's Portfolio - Reconnection</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
</head>
<body class="reconnection-page">
    
    <!-- Static Background -->
    <div class="static-background"></div>
    
    <!-- Modern Header -->
    <header class="main-header">
        <div class="header-container">
            <div class="header-brand">
                <a href="index.html" class="brand-link">
                    <span class="brand-name">Gavin Schmidt</span>
                    <span class="brand-subtitle">Game Designer, Composer, Programmer, and Software Engineer</span>
                </a>
            </div>

            <button class="hamburger" id="hamburger-menu" aria-label="Toggle navigation menu">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>

            <nav class="main-nav" id="main-nav">
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a href="index.html" class="nav-link">
                            <span class="nav-icon">üè†</span>
                            <span class="nav-text">Home</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="projects.html" class="nav-link">
                            <span class="nav-icon">üéÆ</span>
                            <span class="nav-text">Projects</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="experience.html" class="nav-link">
                            <span class="nav-icon">üíº</span>
                            <span class="nav-text">Work</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="music.html" class="nav-link">
                            <span class="nav-icon">üéµ</span>
                            <span class="nav-text">Music</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="index.html#contact" class="nav-link">
                            <span class="nav-icon">üìß</span>
                            <span class="nav-text">Contact</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="resume.html" class="nav-link nav-link-highlight">
                            <span class="nav-icon">üìÑ</span>
                            <span class="nav-text">Resume</span>
                        </a>
                    </li>
                </ul>
            </nav>
        </div>
    </header>
    <main class="reconnection-showcase">
        <div class="hero-section">
            <img src="Media/Pieces/Reconnection/Reconnection logo.png" alt="Reconnection Logo" class="reconnection-logo">
            <h1 class="project-title">Reconnection</h1>
            <p class="project-tagline">D&D-Inspired Turn-Based Combat Meets Stunning Visuals</p>
        </div>

        <section class="project-overview-section">
            <h2>Project Overview</h2>
            <p class="overview-text">
                Reconnection is a <strong>D&D-inspired turn-based fighting game</strong> built in Unreal Engine, 
                combining tactical combat with beautiful visuals and dynamic narrative choices.  As <strong>Lead 
                Engineer</strong>, I architected the entire combat system in C++, implementing dice-roll mechanics, 
                stat-based calculations, and AI decision-making that brings tabletop RPG combat to life. 
            </p>
        </section>

        <section class="key-features-section">
            <h2>Technical Highlights</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <h3>D&D Combat System</h3>
                    <p>Automated dice rolls, attack/defense calculations, and turn management</p>
                </div>
                <div class="feature-card">
                    <h3>Turn-Based Mechanics</h3>
                    <p>UTurnManager auto-discovers fighters, sorts by initiative, and drives the full round/turn loop via multicast delegates</p>
                </div>
                <div class="feature-card">
                    <h3>Enemy AI System</h3>
                    <p>Utility-scored AI weighs attack, heal, block, and buff actions each turn using health ratios, line-of-sight, and weapon type affinity</p>
                </div>
                <div class="feature-card">
                    <h3>C++ Architecture</h3>
                    <p>Clean, extensible parent classes with virtual functions</p>
                </div>
                <div class="feature-card">
                    <h3>Buff System</h3>
                    <p>Dynamic stat modifications for strategic depth</p>
                </div>
                <div class="feature-card">
                    <h3>Dialogue Choices</h3>
                    <p>Player-driven narrative with branching conversations</p>
                </div>
            </div>
        </section>

        <section class="code-showcase-section">
            <h2>Code Showcase</h2>

            <div class="code-feature">
                <h3>Blueprint Integration & Designer Tools</h3>
                <p class="code-description">
                    The C++ AFighter and UEnemy classes are designed for Blueprint extensibility, allowing 
                    designers to create unique enemy behaviors, player abilities, and combat encounters without 
                    touching code. Key Blueprint-implementable functions include:
                </p>
                <div class="blueprint-showcase">
                    <div class="blueprint-feature">
                        <h4>ü§ñ Enemy AI Behaviors</h4>
                        <ul>
                            <li><strong>ChooseAction()</strong> - Implement custom AI decision trees</li>
                            <li><strong>Conditional logic</strong> - Enemy evaluates player health, buffs, and position</li>
                            <li><strong>Action selection</strong> - Choose between Attack, Heal, Block, or special abilities</li>
                            <li><strong>Difficulty scaling</strong> - Adjust AI aggression and strategy per encounter</li>
                        </ul>
						<!-- <div class="code-container">
							<details>
								<summary>BP_HighLevelEnemyActions - Enemy General Conditional logic</summary>
								<pre><code class="language-cpp">
		// C++ provides the foundation... 
		void UEnemy::StartTurn()
		{
			Super::StartTurn();
			ChooseAction();  // Calls Blueprint implementation
		}

		// ... Blueprints implement the behavior
		void UEnemy::ChooseAction_Implementation()
		{
			// In Blueprint Visual Scripting: 
			// 1. Get Player Fighter reference
			// 2. Check Player Health percentage
			// 3. If Player Health < 30%:
			//      - Aggressive: Call Attack() 80% of time
			//      - Defensive: Call Block() 20% of time
			// 4. If Player Health > 70%:
			//      - Call Heal() if Enemy Health < 50%
			//      - Call Attack() otherwise
			// 5. Apply buffs based on turn count
			// 6. Consider special ability cooldowns
		}

		// Event Delegates allow Blueprint responses
		UFUNCTION()
		void OnPlayerHit(UFighter* Target)
		{
			// Blueprint can respond: 
			// - Spawn damage number widget
			// - Play hit sound
			// - Trigger camera shake
			// - Update health bar UI
			// - Check for low health warnings
		}

		// Dialogue integration example
		UFUNCTION(BlueprintCallable)
		void ProcessDialogueChoice(int32 ChoiceID)
		{
			// Blueprint logic: 
			// - Choice 1 (Intimidate): AddBuff(5, "Attack")
			// - Choice 2 (Persuade): Enemy may flee or join party
			// - Choice 3 (Taunt): Enemy focuses attacks on player
		}
								</code></pre>
							</details>
						</div> -->
                    </div>
                    
                    <div class="blueprint-feature">
                        <h4>‚öîÔ∏è Combat Actions</h4>
                        <ul>
                            <li><strong>Attack()</strong> - Custom attack animations and VFX triggers</li>
                            <li><strong>Heal()</strong> - Healing effects with particle systems</li>
                            <li><strong>Block()</strong> - Defensive stance animations</li>
                            <li><strong>Die()</strong> - Death sequences, loot drops, victory conditions</li>
                        </ul>
						<!-- <div class="code-container">
							<details>
								<summary>BP_PlayerActions - Implemented player actions</summary>
								<pre><code class="language-cpp">
		// C++ provides the foundation... 
		void UEnemy::StartTurn()
		{
			Super::StartTurn();
			ChooseAction();  // Calls Blueprint implementation
		}

		// ... Blueprints implement the behavior
		void UEnemy::ChooseAction_Implementation()
		{
			// In Blueprint Visual Scripting: 
			// 1. Get Player Fighter reference
			// 2. Check Player Health percentage
			// 3. If Player Health < 30%:
			//      - Aggressive: Call Attack() 80% of time
			//      - Defensive: Call Block() 20% of time
			// 4. If Player Health > 70%:
			//      - Call Heal() if Enemy Health < 50%
			//      - Call Attack() otherwise
			// 5. Apply buffs based on turn count
			// 6. Consider special ability cooldowns
		}

		// Event Delegates allow Blueprint responses
		UFUNCTION()
		void OnPlayerHit(UFighter* Target)
		{
			// Blueprint can respond: 
			// - Spawn damage number widget
			// - Play hit sound
			// - Trigger camera shake
			// - Update health bar UI
			// - Check for low health warnings
		}

		// Dialogue integration example
		UFUNCTION(BlueprintCallable)
		void ProcessDialogueChoice(int32 ChoiceID)
		{
			// Blueprint logic: 
			// - Choice 1 (Intimidate): AddBuff(5, "Attack")
			// - Choice 2 (Persuade): Enemy may flee or join party
			// - Choice 3 (Taunt): Enemy focuses attacks on player
		}
								</code></pre>
							</details>
						</div> -->
                    </div>
                    
                    <div class="blueprint-feature">
                        <h4>üéØ Event Delegates</h4>
                        <ul>
                            <li><strong>OnStartTurn</strong> - Trigger UI updates, camera effects</li>
                            <li><strong>OnEndTurn</strong> - Queue next fighter in initiative order</li>
                            <li><strong>OnHitAttack</strong> - Play hit reactions, damage numbers</li>
                            <li><strong>OnHitMiss</strong> - Miss animations, combat feedback</li>
                        </ul>
                    </div>
                    
                    <div class="blueprint-feature">
                        <h4>üí¨ Dialogue Integration</h4>
                        <ul>
                            <li><strong>Dynamic choices</strong> - Player dialogue affects combat stats</li>
                            <li><strong>Narrative branching</strong> - Choices influence enemy behavior</li>
                            <li><strong>Combat triggers</strong> - Dialogue can start/end encounters</li>
                            <li><strong>Character relationships</strong> - Track player decisions for story outcomes</li>
                        </ul>
						<!--<div class="code-container">
							<details>
								<summary>BP_DialogueStruct - Structure for setting new dialogue options</summary>
								<pre><code class="language-cpp">
		// C++ provides the foundation... 
		void UEnemy::StartTurn()
		{
			Super::StartTurn();
			ChooseAction();  // Calls Blueprint implementation
		}

		// ... Blueprints implement the behavior
		void UEnemy::ChooseAction_Implementation()
		{
			// In Blueprint Visual Scripting: 
			// 1. Get Player Fighter reference
			// 2. Check Player Health percentage
			// 3. If Player Health < 30%:
			//      - Aggressive: Call Attack() 80% of time
			//      - Defensive: Call Block() 20% of time
			// 4. If Player Health > 70%:
			//      - Call Heal() if Enemy Health < 50%
			//      - Call Attack() otherwise
			// 5. Apply buffs based on turn count
			// 6. Consider special ability cooldowns
		}

		// Event Delegates allow Blueprint responses
		UFUNCTION()
		void OnPlayerHit(UFighter* Target)
		{
			// Blueprint can respond: 
			// - Spawn damage number widget
			// - Play hit sound
			// - Trigger camera shake
			// - Update health bar UI
			// - Check for low health warnings
		}

		// Dialogue integration example
		UFUNCTION(BlueprintCallable)
		void ProcessDialogueChoice(int32 ChoiceID)
		{
			// Blueprint logic: 
			// - Choice 1 (Intimidate): AddBuff(5, "Attack")
			// - Choice 2 (Persuade): Enemy may flee or join party
			// - Choice 3 (Taunt): Enemy focuses attacks on player
		}
								</code></pre>
							</details>
						</div> -->
                    </div>
                </div>
            </div>

            <div class="code-feature">
                <h3>AFighter Class - Combat System Foundation</h3>
                <p class="code-description">
                    The AFighter parent class implements all core combat mechanics including turn management, 
                    dice-roll calculations (d20 system), damage/healing, and buff systems.  Designed with 
                    Blueprint integration for designer flexibility while maintaining C++ performance.
                </p>
                <div class="code-container">
                    <details>
                        <summary>AFighter. h - Header Definition</summary>
                        <pre><code class="language-cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "AFighter.generated.h"

UCLASS()
class RECONNECTION_API AFighter : public AActor
{
    GENERATED_BODY()
    
public:	
    // Sets default values for this actor's properties
    AFighter();

    //Boolean to check if it's this fighter's turn
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Stored Variables")
    bool bIsTurn;

    //Initiative score for turn order
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Stored Variables")
    int32 InitiativeScore;

    //Function to start this fighter's turn
    UFUNCTION(BlueprintCallable, Category="Stored Functions")
    void StartTurn();

    //Function to end this fighter's turn	
    UFUNCTION(BlueprintCallable, Category="Stored Functions")
    void EndTurn();

    UFUNCTION(BlueprintCallable, Category = "Stored Functions")
    void SendDamage(float Damage, const FString& Type, AFighter *Target);

    UFUNCTION(BlueprintCallable, Category = "Stored Functions")
    virtual void ReceiveDamage(float Damage, const FString& Type);

protected:
    // Called when the game starts or when spawned
    virtual void BeginPlay() override;

};
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>Turn Management & Combat Flow</h3>
                <p class="code-description">
                    Implements initiative-based turn order system with clear turn start/end demarcation. 
                    The turn management system allows for complex action queuing and supports both player 
                    and AI-controlled fighters. 
                </p>
                <div class="code-container">
                    <details>
                        <summary>AFighter.cpp - Turn System Implementation</summary>
                        <pre><code class="language-cpp">
// Fill out your copyright notice in the Description page of Project Settings. 

#include "AFighter.h"

void AFighter::BeginPlay()
{
    Super::BeginPlay();
}

// Sets default values
AFighter::AFighter()
{
    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it. 
    PrimaryActorTick. bCanEverTick = false;

    bIsTurn = false;
    InitiativeScore = 0;
}

void AFighter::StartTurn()
{
    bIsTurn = true;
    UE_LOG(LogTemp, Warning, TEXT("Turn started"));
}

void AFighter::EndTurn()
{
    bIsTurn = false;
    UE_LOG(LogTemp, Warning, TEXT("Turn ended"));
}

void AFighter:: SendDamage(float Damage, const FString& Type, AFighter *Target)
{
    UE_LOG(LogTemp, Warning, TEXT("Sending %f %s damage to target"), Damage, *Type);
}

void AFighter::ReceiveDamage(float Damage, const FString& Type)
{
    UE_LOG(LogTemp, Warning, TEXT("Received %f %s damage from source"), Damage, *Type);
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>D&D-Style Dice Roll System</h3>
                <p class="code-description">
                    From the original UFighter implementation:  Authentic d20 attack rolls with modifiers, 
                    defense calculations, and random damage ranges. This creates unpredictable, strategic 
                    combat that feels like tabletop D&D.
                </p>
                <div class="code-container">
                    <details>
                        <summary>UFighter.cpp - Attack & Defense Mechanics</summary>
                        <pre><code class="language-cpp">
// D20 Attack Roll System
int UFighter::RollToHit()
{
    int Roll = FMath::RandRange(1, 20);  // d20 roll
    return Roll + BaseAttack + AttackBuff;
}

float UFighter::GetDefense()
{
    return BaseDefense + DefenseBuff;
}

void UFighter:: Attack(UFighter *Target)
{
    // Roll to hit vs target defense (classic D&D mechanic)
    if (RollToHit() >= Target->GetDefense())
    {
        SendDamage(RollDamage(), Target);
        OnHitAttack. Broadcast(Target);
    }
    else
    {
        OnHitMiss.Broadcast(Target);
    }
    EndTurn();
}

float UFighter::RollDamage()
{
    // Random damage range with buffs
    float Damage = FMath::RandRange(MinDamage, MaxDamage) + DamageBuff;
    return Damage;
}

void UFighter:: ReceiveDamage_Implementation(float Damage)
{
    // Apply damage with reduction/armor
    CurrentHealth = FMath::Clamp(CurrentHealth - (Damage - DamageReduction), 0.0f, MaxHealth);
    if (CurrentHealth <= 0)
    {
        Die();
        UE_LOG(LogTemp, Warning, TEXT("Fighter has been defeated"));
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>Strategic Action System</h3>
                <p class="code-description">
                    Multiple combat actions beyond basic attacks:  healing, blocking, and buff management. 
                    Each action has strategic tradeoffs, encouraging thoughtful decision-making during combat. 
                </p>
                <div class="code-container">
                    <details>
                        <summary>UFighter.cpp - Heal, Block, & Buff Systems</summary>
                        <pre><code class="language-cpp">
// Healing Action
void UFighter::Heal_Implementation()
{
    CurrentHealth = FMath::Clamp(CurrentHealth + BaseHeal, 0.0f, MaxHealth);
    EndTurn();
}

// Blocking/Defensive Action
void UFighter::Block_Implementation()
{
    DamageReduction = BaseBlock + BlockBuff;
    EndTurn();
}

// Dynamic Buff System
void UFighter::AddBuff(float BuffAmount, const FString& stat)
{
    if (stat == "Attack")
    {
        AttackBuff += BuffAmount;
    }
    else if (stat == "Damage")
    {
        DamageBuff += BuffAmount;
    }
    else if (stat == "Defense")
    {
        DefenseBuff += BuffAmount;
    }
    else if (stat == "Block")
    {
        BlockBuff += BuffAmount;
    }
    else if (stat == "Heal")
    {
        HealBuff += BuffAmount;
    }
}

void UFighter:: RemoveBuff(float BuffAmount, const FString& stat)
{
    if (stat == "Attack")
        AttackBuff -= BuffAmount;
    else if (stat == "Damage")
        DamageBuff -= BuffAmount;
    else if (stat == "Defense")
        DefenseBuff -= BuffAmount;
    else if (stat == "Block")
        BlockBuff -= BuffAmount;
    else if (stat == "Heal")
        HealBuff -= BuffAmount;
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>UEnemy - Fighter Enemy Architecture</h3>
                <p class="code-description">
                    <code>UEnemy</code> inherits from <code>UFighter</code> and adds a full utility-based AI decision system.
                    Enemies track allies and opponents separately, evaluate weighted utility scores for every possible action,
                    and automatically choose the highest-value action each turn. Weapon type awareness (Melee, Ranged, Magic)
                    further biases the AI's attack preference, and all utility weights are <code>EditAnywhere</code> so designers
                    can tune behavior per enemy type without touching code.
                </p>
                <div class="code-container">
                    <details>
                        <summary>UEnemy.h - Header &amp; Weapon Type Enum</summary>
                        <pre><code class="language-cpp">
UENUM(BlueprintType)
enum class EWeaponType : uint8
{
    Melee  UMETA(DisplayName = "Melee"),
    Ranged UMETA(DisplayName = "Ranged"),
    Magic  UMETA(DisplayName = "Magic")
};

UCLASS(ClassGroup = (Fighters), meta = (BlueprintSpawnableComponent))
class RECONNECTION_API UEnemy : public UFighter
{
    GENERATED_BODY()

public:
    virtual void StartTurn() override;

    // Blueprint-implementable AI entry point
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Enemy|Combat")
    void ChooseAction();
    virtual void ChooseAction_Implementation();

    // Roster management
    UFUNCTION(BlueprintCallable, Category = "Enemy|Setup")
    void InitializeEnemy(const TArray&lt;UFighter*&gt;&amp; AllFighters);
    UFUNCTION(BlueprintCallable, Category = "Enemy|Setup")
    void UpdateAlliesAndEnemies(const TArray&lt;UFighter*&gt;&amp; AllFighters);
    UFUNCTION(BlueprintCallable, Category = "Enemy|Setup")
    void OnFighterListChanged(UFighter* ChangedFighter);

    virtual void ReceiveDamage(float Damage) override;

    // --- Utility scorers ---
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetAttackUtility();
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetMeleeUtility();
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetRangedUtility();
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetMagicUtility();
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetSelfHealUtility();
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetAllyHealUtility();
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetBlockUtility();
    UFUNCTION(BlueprintCallable, Category = "Enemy|Utility")
    float GetBuffUtility();

    // Tunable weights exposed to designers
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    float AttackUtilityWeight;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    bool bHasMelee;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    bool bHasRanged;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    bool bHasMagic;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    float HealUtilityWeight;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    bool bHasSelfHeal;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    bool bHasAllyHeal;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    float BuffUtilityWeight;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    bool bHasBuff;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    float BlockUtilityWeight;
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "Enemy|Utility|Weight")
    bool bHasBlock;

    UFUNCTION(BlueprintCallable, Category = "Enemy|StorageAccess")
    UFighter* GetClosestEnemy();
    UFUNCTION(BlueprintCallable, Category = "Enemy|StorageAccess")
    UFighter* GetLowestAlly();

private:
    TArray&lt;UFighter*&gt; Allies;
    TArray&lt;UFighter*&gt; Enemies;
    float LastDamageReceived;
    int ClosestEnemyIndex;
    int LowestAllyIndex;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Enemy|Weapon",
              meta = (AllowPrivateAccess = "true"))
    EWeaponType CurrentWeaponType = EWeaponType::Melee;
};
                        </code></pre>
                    </details>
                </div>
                <div class="code-container">
                    <details>
                        <summary>UEnemy.cpp - Ally &amp; Enemy Roster Tracking</summary>
                        <pre><code class="language-cpp">
void UEnemy::InitializeEnemy(const TArray&lt;UFighter*&gt;&amp; AllFighters)
{
    Allies.Empty();
    for (UFighter* Fighter : AllFighters)
    {
        if (Fighter &amp;&amp; Fighter-&gt;GetOwner() != GetOwner())
        {
            if (Fighter-&gt;GetOwner()-&gt;FindComponentByClass&lt;UEnemy&gt;())
                Allies.Add(Fighter);   // Same faction
            else
                Enemies.Add(Fighter);  // Opposing faction
        }
    }
}

void UEnemy::UpdateAlliesAndEnemies(const TArray&lt;UFighter*&gt;&amp; AllFighters)
{
    Allies.Empty();
    Enemies.Empty();
    for (UFighter* Fighter : AllFighters)
    {
        if (Fighter &amp;&amp; Fighter-&gt;GetOwner() != GetOwner())
        {
            if (Fighter-&gt;GetOwner()-&gt;FindComponentByClass&lt;UEnemy&gt;())
                Allies.Add(Fighter);
            else
                Enemies.Add(Fighter);
        }
    }
}

// Called by UTurnManager delegates whenever a fighter joins or dies
void UEnemy::OnFighterListChanged(UFighter* /*ChangedFighter*/)
{
    UWorld* World = GetWorld();
    if (!World) return;
    for (TObjectIterator&lt;UTurnManager&gt; It; It; ++It)
    {
        if (It-&gt;GetWorld() == World)
        {
            UpdateAlliesAndEnemies(It-&gt;Fighters);
            break;
        }
    }
}

void UEnemy::ReceiveDamage(float Damage)
{
    Super::ReceiveDamage(Damage);
    LastDamageReceived = Damage;  // Stored for block utility scoring
}
                        </code></pre>
                    </details>
                </div>
                <div class="code-container">
                    <details>
                        <summary>UEnemy.cpp - Utility AI Scoring System</summary>
                        <pre><code class="language-cpp">
// Attack utility: drives aggression based on target's remaining health.
// Uses -ln(healthRatio) so near-dead targets score exponentially higher.
float UEnemy::GetAttackUtility()
{
    float CurrUtility = 0;
    ClosestEnemyIndex = 0;
    if (Enemies.Num() &lt;= 0) return CurrUtility;

    float ClosestDistance = Enemies[0]-&gt;GetOwner()-&gt;GetHorizontalDistanceTo(this-&gt;GetOwner());
    bool bHasLineOfSight = false;

    int i = 0;
    for (UFighter* CurrFighter : Enemies)
    {
        float Dist = CurrFighter-&gt;GetOwner()-&gt;GetHorizontalDistanceTo(this-&gt;GetOwner());
        if (Dist &lt; ClosestDistance) { ClosestEnemyIndex = i; ClosestDistance = Dist; }
        if (CheckSightToTarget(CurrFighter)) bHasLineOfSight = true;
        ++i;
    }

    if ((ClosestDistance &gt; MovementLeft &amp;&amp; !bHasRanged) || !bHasLineOfSight)
        return CurrUtility;

    float HealthRatio = FMath::Clamp(
        Enemies[ClosestEnemyIndex]-&gt;CurrentHealth / Enemies[ClosestEnemyIndex]-&gt;MaxHealth,
        0.01f, 1.0f);
    CurrUtility += -FMath::Loge(HealthRatio);
    return CurrUtility * AttackUtilityWeight;
}

// Self-heal: exponential urgency; forced (FLT_MAX) at &lt;=10% health.
float UEnemy::GetSelfHealUtility()
{
    if (!bHasSelfHeal) return 0;
    float HealthRatio = FMath::Clamp(CurrentHealth / MaxHealth, 0.01f, 1.0f);
    if (HealthRatio &lt;= 0.1f)
        return FLT_MAX;  // Force heal when critically low
    return FMath::Exp(-HealthRatio * 5.0f) * HealUtilityWeight;
}

// Ally heal: finds the most wounded visible ally and scores by their need.
float UEnemy::GetAllyHealUtility()
{
    if (!bHasAllyHeal) return 0;
    float LowestHealthRatio = FLT_MAX;
    LowestAllyIndex = 0;
    int i = 0;
    for (auto Ally : Allies)
    {
        if (CheckSightToTarget(Ally))
        {
            float Ratio = Ally-&gt;CurrentHealth / Ally-&gt;MaxHealth;
            if (Ratio &lt; LowestHealthRatio) { LowestAllyIndex = i; LowestHealthRatio = Ratio; }
        }
        ++i;
    }
    return FMath::Exp(-LowestHealthRatio * 5.0f) * HealUtilityWeight;
}

// Block: scales with recent incoming damage so reactive enemies defend wisely.
float UEnemy::GetBlockUtility()
{
    if (!bHasBlock) return 0;
    float DamageRatio = FMath::Clamp(LastDamageReceived / MaxHealth, 0.0f, 1.0f);
    return (FMath::Exp(DamageRatio * BlockUtilityWeight) - 1.0f) * BlockUtilityWeight;
}

// Buff: rewards buffing when no active buffs exist, diminishes per existing buff.
float UEnemy::GetBuffUtility()
{
    if (!bHasBuff) return 0;
    float CurrUtility = (BuffTracker.Num() == 0) ? 1.0f : 0.5f / BuffTracker.Num();
    return CurrUtility * BuffUtilityWeight;
}

// Weapon-type affinity: preferred weapon scores 1.0, off-type scores lower.
float UEnemy::GetMeleeUtility()  { return bHasMelee  ? (CurrentWeaponType == EWeaponType::Melee  ? 1.0f : 0.3f) : 0; }
float UEnemy::GetRangedUtility() { return bHasRanged ? (CurrentWeaponType == EWeaponType::Ranged ? 1.0f : 0.5f) : 0; }
float UEnemy::GetMagicUtility()  { return bHasMagic  ? (CurrentWeaponType == EWeaponType::Magic  ? 1.0f : 0.6f) : 0; }
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>Comprehensive Stat System</h3>
                <p class="code-description">
                    Tracks 15+ combat statistics including initiative, health, damage ranges, attack bonuses, 
                    defense values, and buff modifiers.  Provides a complete stat query system for UI and 
                    game logic. 
                </p>
                <div class="code-container">
                    <details>
                        <summary>UFighter.cpp - Stat Management</summary>
                        <pre><code class="language-cpp">
TArray&lt;float&gt; UFighter::GetAllStats()
{
    TArray&lt;float&gt; Stats;
    Stats.Add(InitiativeScore);
    Stats.Add(MaxHealth);
    Stats.Add(CurrentHealth);
    Stats.Add(MinDamage);
    Stats.Add(MaxDamage);
    Stats.Add(DamageBuff);
    Stats.Add(BaseAttack);
    Stats.Add(AttackBuff);
    Stats.Add(BaseDefense);
    Stats.Add(DefenseBuff);
    Stats.Add(BaseBlock);
    Stats.Add(BlockBuff);
    Stats.Add(BaseHeal);
    Stats.Add(HealBuff);
    Stats.Add(DamageReduction);
    return Stats;
}

// Example stat usage in combat
void UFighter::SendDamage_Implementation(float Damage, UFighter* Target)
{
    Target->ReceiveDamage(Damage);
}

void UFighter::Die_Implementation()
{
    // Handle death logic here in Blueprint
    // Can trigger animations, VFX, game over states, etc.
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>UTurnManager - Combat Orchestration</h3>
                <p class="code-description">
                    <code>UTurnManager</code> is an <code>ActorComponent</code> that owns the entire combat loop.
                    On <code>BeginPlay</code> it scans every actor in the world for <code>UFighter</code> components,
                    sorts them by initiative, binds to their death and end-turn delegates, and waits for a
                    <code>StartCombat()</code> call. Five Blueprint-assignable multicast delegates let UI, cameras,
                    and audio respond to every state change without any hard coupling.
                </p>
                <div class="code-container">
                    <details>
                        <summary>UTurnManager.h - Delegates &amp; Public Interface</summary>
                        <pre><code class="language-cpp">
// Multicast delegates - bind anything in Blueprint with no code changes
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTurnChanged,   UFighter*, CurrentFighter);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnRoundStarted);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCombatEnded);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnFighterDeath,  UFighter*, DeadFighter);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnFighterJoined, UFighter*, NewFighter);

UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class RECONNECTION_API UTurnManager : public UActorComponent
{
    GENERATED_BODY()
public:
    UTurnManager();

    UPROPERTY(BlueprintReadOnly,  Category = "Turn Manager") TArray&lt;UFighter*&gt; Fighters;
    UPROPERTY(BlueprintReadOnly,  Category = "Turn Manager") int32 CurrentTurnIndex;
    UPROPERTY(BlueprintReadOnly,  Category = "Turn Manager") int32 CurrentRound;
    UPROPERTY(BlueprintReadWrite, Category = "Turn Manager") bool  bCombatActive;
    UPROPERTY(BlueprintReadOnly,  Category = "Turn Manager") int32 EnemiesLeft = 0;
    UPROPERTY(BlueprintReadWrite, Category = "Turn Manager") FName NextLevel;

    // Events - assign UI, audio, cameras entirely from Blueprint
    UPROPERTY(BlueprintAssignable, Category = "Turn Manager|Events") FOnTurnChanged   OnTurnChanged;
    UPROPERTY(BlueprintAssignable, Category = "Turn Manager|Events") FOnRoundStarted  OnRoundStarted;
    UPROPERTY(BlueprintAssignable, Category = "Turn Manager|Events") FOnCombatEnded   OnCombatEnded;
    UPROPERTY(BlueprintAssignable, Category = "Turn Manager|Events") FOnFighterDeath  OnFighterDeath;
    UPROPERTY(BlueprintAssignable, Category = "Turn Manager|Events") FOnFighterJoined OnFighterJoined;

    UFUNCTION(BlueprintCallable, Category = "Turn Manager") void InitializeCombat();
    UFUNCTION(BlueprintCallable, Category = "Turn Manager") void StartCombat();
    UFUNCTION(BlueprintCallable, Category = "Turn Manager") void NextTurn();
    UFUNCTION(BlueprintCallable, Category = "Turn Manager") UFighter* GetCurrentFighter();
    UFUNCTION(BlueprintCallable, Category = "Turn Manager") void SortFightersByInitiative();
    UFUNCTION(BlueprintCallable, Category = "Turn Manager") void RemoveFighter(UFighter* Fighter);
    UFUNCTION(BlueprintCallable, Category = "Turn Manager") void EndCombat();

private:
    UFUNCTION() void HandleFighterDeath(UFighter* DeadFighter);
    UFUNCTION() void HandleFighterEndTurn(UFighter* Fighter);
};
                        </code></pre>
                    </details>
                </div>
                <div class="code-container">
                    <details>
                        <summary>UTurnManager.cpp - InitializeCombat &amp; StartCombat</summary>
                        <pre><code class="language-cpp">
void UTurnManager::BeginPlay()
{
    Super::BeginPlay();
    InitializeCombat();
}

void UTurnManager::InitializeCombat()
{
    Fighters.Empty();

    // Iterate every actor and collect those with a UFighter component
    TArray&lt;AActor*&gt; AllActors;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), AllActors);

    for (AActor* Actor : AllActors)
    {
        if (!Actor) continue;
        UFighter* FighterComp = Actor-&gt;FindComponentByClass&lt;UFighter&gt;();
        if (!FighterComp) continue;

        Fighters.Add(FighterComp);

        // Bind death &amp; turn-end events for automatic flow control
        FighterComp-&gt;OnDeath.AddDynamic(this, &amp;UTurnManager::HandleFighterDeath);
        FighterComp-&gt;OnEndTurn.AddDynamic(this, &amp;UTurnManager::HandleFighterEndTurn);

        // If the actor also has an UEnemy component, wire up roster-update delegates
        UEnemy* EnemyComp = Actor-&gt;FindComponentByClass&lt;UEnemy&gt;();
        if (EnemyComp)
        {
            EnemyComp-&gt;InitializeEnemy(Fighters);
            OnFighterJoined.AddDynamic(EnemyComp, &amp;UEnemy::OnFighterListChanged);
            OnFighterDeath.AddDynamic(EnemyComp,  &amp;UEnemy::OnFighterListChanged);
            ++EnemiesLeft;
        }
        OnFighterJoined.Broadcast(FighterComp);
    }

    SortFightersByInitiative();
    // StartCombat() is called separately so Blueprint can delay the start
}

void UTurnManager::StartCombat()
{
    if (Fighters.Num() == 0) { return; }

    bCombatActive = true;
    CurrentTurnIndex = 0;
    CurrentRound = 1;
    OnRoundStarted.Broadcast();

    // Reset all turns, then give the first fighter their turn
    for (UFighter* Fighter : Fighters)
        if (Fighter &amp;&amp; Fighter-&gt;bIsTurn) Fighter-&gt;bIsTurn = false;

    UFighter* FirstFighter = GetCurrentFighter();
    if (FirstFighter)
    {
        FirstFighter-&gt;StartTurn();
        OnTurnChanged.Broadcast(FirstFighter);
    }
}
                        </code></pre>
                    </details>
                </div>
                <div class="code-container">
                    <details>
                        <summary>UTurnManager.cpp - NextTurn, Round Tracking &amp; Initiative Sort</summary>
                        <pre><code class="language-cpp">
void UTurnManager::NextTurn()
{
    if (!bCombatActive || Fighters.Num() == 0) return;

    CurrentTurnIndex++;

    // Wrap index ‚Üí new round
    if (CurrentTurnIndex &gt;= Fighters.Num())
    {
        CurrentTurnIndex = 0;
        CurrentRound++;
        OnRoundStarted.Broadcast();
    }

    // Clear any lingering active turns
    for (UFighter* Fighter : Fighters)
        if (Fighter &amp;&amp; Fighter-&gt;bIsTurn) Fighter-&gt;bIsTurn = false;

    UFighter* CurrentFighter = GetCurrentFighter();
    if (CurrentFighter)
    {
        CurrentFighter-&gt;StartTurn();
        OnTurnChanged.Broadcast(CurrentFighter);
    }
}

UFighter* UTurnManager::GetCurrentFighter()
{
    return Fighters.IsValidIndex(CurrentTurnIndex) ? Fighters[CurrentTurnIndex] : nullptr;
}

// Descending sort - highest initiative goes first (classic D&D tiebreaker by score)
void UTurnManager::SortFightersByInitiative()
{
    Fighters.Sort([](const UFighter&amp; A, const UFighter&amp; B)
    {
        return A.InitiativeScore &gt; B.InitiativeScore;
    });
}

// Called by HandleFighterEndTurn delegate
void UTurnManager::HandleFighterEndTurn(UFighter* Fighter)
{
    if (bCombatActive) NextTurn();
}
                        </code></pre>
                    </details>
                </div>
                <div class="code-container">
                    <details>
                        <summary>UTurnManager.cpp - Fighter Removal, Victory &amp; Level Transition</summary>
                        <pre><code class="language-cpp">
void UTurnManager::RemoveFighter(UFighter* Fighter)
{
    if (!Fighter) return;

    int32 RemovedIndex = Fighters.Find(Fighter);
    if (RemovedIndex == INDEX_NONE) return;

    Fighters.Remove(Fighter);

    // Keep CurrentTurnIndex valid after removal
    if (RemovedIndex &lt; CurrentTurnIndex)
        CurrentTurnIndex--;
    else if (RemovedIndex == CurrentTurnIndex &amp;&amp; CurrentTurnIndex &gt;= Fighters.Num())
        CurrentTurnIndex = 0;

    if (Fighters.Num() &lt;= 1) EndCombat();
}

void UTurnManager::EndCombat()
{
    bCombatActive = false;
    OnCombatEnded.Broadcast();
}

// Bound to each fighter's OnDeath delegate during InitializeCombat()
void UTurnManager::HandleFighterDeath(UFighter* DeadFighter)
{
    OnFighterDeath.Broadcast(DeadFighter);
    RemoveFighter(DeadFighter);

    // If it was an enemy, decrement counter and load the next level on victory
    if (DeadFighter-&gt;GetOwner()-&gt;FindComponentByClass&lt;UEnemy&gt;())
    {
        --EnemiesLeft;
        if (EnemiesLeft &lt;= 0)
        {
            UGameplayStatics::OpenLevel(GetWorld(), FName(NextLevel));
        }
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>
        </section>

        <section class="blueprint-images-section">
            <h2>Blueprint Showcases</h2>
            <p class="overview-text">Unreal Engine Blueprint graphs built on top of the C++ foundation, handling AI decision-making, movement validation, and input processing.</p>
            <div class="blueprint-gallery-grid">
                <div class="blueprint-gallery-item">
                    <img src="Media/Pieces/Reconnection/AI State Tree.png" alt="Enemy AI State Tree Blueprint" loading="lazy">
                    <p class="blueprint-gallery-caption">AI State Tree</p>
                    <p class="blueprint-gallery-description">The central thinking loop for every enemy. This Blueprint reads utility scores calculated in <code>UEnemy.cpp</code> and drives the State Tree that determines which action each enemy takes on their turn.</p>
                </div>
                <div class="blueprint-gallery-item">
                    <img src="Media/Pieces/Reconnection/Enemy Brain 1.png" alt="Enemy Brain Blueprint - Part 1" loading="lazy">
                    <p class="blueprint-gallery-caption">Enemy Brain (Part 1 of 2)</p>
                    <p class="blueprint-gallery-description">The Enemy Brain graph initializes State Tree thoughts and instructs each enemy how to act upon them, translating the utility AI system into concrete in-world decisions.</p>
                </div>
                <div class="blueprint-gallery-item">
                    <img src="Media/Pieces/Reconnection/Enemy Brain 2.png" alt="Enemy Brain Blueprint - Part 2" loading="lazy">
                    <p class="blueprint-gallery-caption">Enemy Brain (Part 2 of 2)</p>
                    <p class="blueprint-gallery-description">Continuation of the Enemy Brain graph, showing the downstream action execution after the State Tree has resolved which behavior scores highest for that turn.</p>
                </div>
                <div class="blueprint-gallery-item">
                    <img src="Media/Pieces/Reconnection/Ghost Mover.png" alt="Ghost Mover Blueprint" loading="lazy">
                    <p class="blueprint-gallery-caption">Ghost Mover</p>
                    <p class="blueprint-gallery-description">A ghost mesh that pathfinds to the player's clicked destination and validates whether the target position is reachable within the player's movement constraints before committing the move.</p>
                </div>
                <div class="blueprint-gallery-item">
                    <img src="Media/Pieces/Reconnection/Player Mouse Tracker.png" alt="Player Mouse Tracker Blueprint" loading="lazy">
                    <p class="blueprint-gallery-caption">Player Mouse Tracker</p>
                    <p class="blueprint-gallery-description">Line traces the mouse cursor on click to determine what was hit in the world, then routes that hit information back to Blueprint for downstream gameplay logic such as targeting and movement commands.</p>
                </div>
            </div>
        </section>

        <section class="team-section">
            <h2>Team Credits</h2>
            <div class="team-grid">
                <a href="https://jadynenglett.weebly.com" class="team-member" target="_blank" rel="noopener noreferrer" style="text-decoration: none; display: block;">
                    <div class="team-icon">üé¨</div>
                    <strong>Jadyn Englett</strong>
                    <span>Producer & Level Design</span>
                </a>
                <div class="team-member">
                    <div class="team-icon">üñåÔ∏è</div>
                    <strong>Waldemar Morales</strong>
                    <span>Character Art, UI Art, Art Lead</span>
                </div>
                <div class="team-member">
                    <div class="team-icon">üéÆ</div>
                    <strong>Wesley Yates</strong>
                    <span>Front-End Blueprints, Level Design, and Tech Lead</span>
                </div>
                <div class="team-member">
                    <div class="team-icon">üé®</div>
                    <strong>Olin Britt-Tores</strong>
                    <span>Character Art & 3D Environment</span>
                </div>
                <div class="team-member">
                    <div class="team-icon">üìñ</div>
                    <strong>Matthew Polfer</strong>
                    <span>Narrative & Level Design</span>
                </div>
                <div class="team-member">
                    <div class="team-icon">üì∑</div>
                    <strong>David Diaz</strong>
                    <span>Camera & Post-Processing</span>
                </div>
                <div class="team-member">
                    <div class="team-icon">‚ú®</div>
                    <strong>Daniel Roa</strong>
                    <span>VFX & Animations</span>
                </div>
            </div>
        </section>

        <section class="reflection-section">
            <h2>Developer Reflection</h2>
            <blockquote>
                Building Reconnection taught me the importance of designing C++ systems that empower 
                designers. By creating a robust combat foundation with Blueprint extensibility, our team 
                could iterate rapidly on enemy behaviors and game balance while maintaining performant, 
                clean code. Translating the unpredictability and strategy of tabletop D&D into automated 
                combat was an incredibly rewarding challenge! 
            </blockquote>
        </section>
    </main>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="footer-container">
            <p class="footer-text">
                ¬© 2026 Gavin Schmidt. All rights reserved.
            </p>
            <div class="footer-links">
                <a href="index.html">Home</a>
                <span class="footer-separator">‚Ä¢</span>
                <a href="projects.html">Projects</a>
                <span class="footer-separator">‚Ä¢</span>
                <a href="music.html">Music</a>
                <span class="footer-separator">‚Ä¢</span>
                <a href="resume.html">Resume</a>
            </div>
        </div>
    </footer>

    <!-- Mobile Menu Script -->
    <script src="header.js"></script>
    <script src="lightbox.js"></script>
</body>
</html>