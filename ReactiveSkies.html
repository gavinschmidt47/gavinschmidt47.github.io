<! DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C47TXLXECX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-C47TXLXECX');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Gavin Schmidt's Portfolio - Reactive Skies</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min. js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min. js"></script>
</head>
<body>
    <header>
        <h1>Gavin Schmidt's Portfolio</h1>
        <nav>
            <ul class="nav-menu" id="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="music.html">Music</a></li>
                <li><a href="index.html#contact">Contact</a></li>
                <li><a href="resume.html">Resume</a></li>
            </ul>
        </nav>
    </header>
    <main class="reactiveskies-showcase">
        <div class="hero-section">
            <img src="Media/Pieces/Reactive Skies/Reactive Skies scene.png" alt="Reactive Skies Scene" class="reactiveskies-logo">
            <h1 class="project-title">Reactive Skies</h1>
            <p class="project-tagline">Real-Time Weather Integration & Cloud Services Playground</p>
        </div>

        <section class="project-overview-section">
            <h2>üå§Ô∏è Project Overview</h2>
            <p class="overview-text">
                Reactive Skies began as a <strong>class lab project</strong> focused on API integration and 
                cloud services, but has since evolved into my personal <strong>experimental playground</strong> 
                for testing cutting-edge Unity features. The project demonstrates real-time weather data 
                integration using the <strong>OpenWeatherMap API</strong>, user authentication through 
                <strong>PlayFab</strong>, and optimized data caching strategies.  It's become my go-to sandbox 
                for exploring new APIs, testing backend services, and prototyping network features before 
                implementing them in larger projects.
            </p>
        </section>

        <section class="key-features-section">
            <h2>‚ö° Technical Highlights</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <div class="feature-icon">üå¶Ô∏è</div>
                    <h3>Real-Time Weather API</h3>
                    <p>OpenWeatherMap integration with dynamic skybox switching</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üîê</div>
                    <h3>PlayFab Authentication</h3>
                    <p>Email and device-based login with persistent sessions</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üíæ</div>
                    <h3>Smart Caching System</h3>
                    <p>Local storage optimization for images and data</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üåê</div>
                    <h3>XML Parsing</h3>
                    <p>Robust API response handling with error management</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üé®</div>
                    <h3>Dynamic Lighting</h3>
                    <p>Time-based lighting adjustments from sunrise/sunset data</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üì∏</div>
                    <h3>Screenshot Utility</h3>
                    <p>Timestamped screenshot capture system</p>
                </div>
            </div>
        </section>

        <section class="code-showcase-section">
            <h2>üíª Code Showcase</h2>

            <div class="code-feature">
                <h3>üå¶Ô∏è Dynamic Weather System with API Integration</h3>
                <p class="code-description">
                    The WeatherManager pulls live weather data from OpenWeatherMap's API, parses XML responses, 
                    and dynamically adjusts the game's skybox and lighting based on real-world conditions.  The 
                    system calculates dawn/dusk periods using actual sunrise/sunset times and applies 
                    appropriate atmospheric effects. This was my first deep dive into REST API integration! 
                </p>
                <div class="code-container">
                    <details>
                        <summary>WeatherManager.cs - API Integration & Dynamic Environment</summary>
                        <pre><code class="language-csharp">
using System;
using System.Collections;
using System. Xml.Linq;
using UnityEngine;
using UnityEngine.Networking;

public class WeatherManager : MonoBehaviour
{
    public string location = "Orlando,us";
    public Material clearDawnSkyboxMaterial;
    public Material clearDaySkyboxMaterial;
    public Material clearDuskSkyboxMaterial;
    public Material clearNightSkyboxMaterial;
    public Material rainSkyboxMaterial;
    public Material snowSkyboxMaterial;
    public Light directionalLight;
    public float dawnDuskMargin;

    private enum TimeOfDay { Dawn, Day, Dusk, Night }
    private TimeOfDay currentTimeOfDay;
    private string xmlApi => "http://api.openweathermap.org/data/2.5/weather?q=" + 
                             location + "&mode=xml&appid=dc349e3935101abb942e111db21c2985";

    // Generic API call wrapper with error handling
    private IEnumerator CallAPI(string url, Action<XDocument> callback)
    {
        using (UnityWebRequest request = UnityWebRequest.Get(url))
        {
            yield return request.SendWebRequest();
            if (request.result == UnityWebRequest.Result.ConnectionError)
            {
                Debug.LogError($"network problem: {request.error}");
            }
            else if (request.result == UnityWebRequest. Result. ProtocolError)
            {
                Debug.LogError($"response error: {request.responseCode}");
            }
            else
            {
                callback(XDocument.Parse(request.downloadHandler.text));
            }
        }
    }

    public IEnumerator GetWeatherXML(Action<XDocument> callback)
    {
        return CallAPI(xmlApi, callback);
    }

    void Start() 
    {
        directionalLight.color = Color.white;
        directionalLight.intensity = 1. 0f;
        RenderSettings.skybox = clearDaySkyboxMaterial;
        StartCoroutine(GetWeatherXML(OnXMLDataLoaded));
    }

    public void OnXMLDataLoaded(XDocument data)
    {
        Debug.Log(data);

        if (data. Root. Element("city") != null)
        {
            Debug.Log("Successfully retrieved weather data for " + 
                     data.Root.Element("city").Attribute("name").Value);
        }
        
        DateTime now = DateTime.Now;

        // Parse sunrise/sunset times from API
        XElement sun = data.Root.Element("city").Element("sun");
        DateTime sunrise = DateTime.Parse(sun. Attribute("rise").Value).ToLocalTime();
        DateTime sunset = DateTime.Parse(sun.Attribute("set").Value).ToLocalTime();

        // Determine time of day with margin for dawn/dusk
        if (now < sunrise. AddMinutes(-dawnDuskMargin) || now > sunset.AddMinutes(dawnDuskMargin))
        {
            Debug.Log("It's night time.");
            directionalLight.intensity = 1.3f;
            directionalLight.color = new Color32(55, 95, 135, 255);
            currentTimeOfDay = TimeOfDay. Night;
        }
        else if (now >= sunrise.AddMinutes(-dawnDuskMargin) && now <= sunrise.AddMinutes(dawnDuskMargin))
        {
            Debug.Log("It's dawn.");
            directionalLight.intensity = 1.2f;
            directionalLight. color = new Color32(255, 222, 50, 255);
            currentTimeOfDay = TimeOfDay.Dawn;
        }
        else if (now >= sunset.AddMinutes(-dawnDuskMargin) && now <= sunset.AddMinutes(dawnDuskMargin))
        {
            Debug.Log("It's dusk.");
            directionalLight.intensity = 1.6f;
            directionalLight. color = new Color32(254, 180, 32, 255);
            currentTimeOfDay = TimeOfDay. Dusk;
        }
        else
        {
            Debug. Log("It's daytime.");
            directionalLight. intensity = 1.25f;
            directionalLight. color = new Color32(255, 255, 224, 255);
            currentTimeOfDay = TimeOfDay.Day;
        }

        // Apply appropriate skybox based on time of day
        switch (currentTimeOfDay)
        {
            case TimeOfDay. Dawn:
                RenderSettings. skybox = clearDawnSkyboxMaterial;
                break;
            case TimeOfDay.Day:
                RenderSettings.skybox = clearDaySkyboxMaterial;
                break;
            case TimeOfDay.Dusk:
                RenderSettings. skybox = clearDuskSkyboxMaterial;
                break;
            case TimeOfDay.Night:
                RenderSettings.skybox = clearNightSkyboxMaterial;
                break;
        }

        // Check for precipitation and override skybox
        XElement weather = data.Root.Element("precipitation");
        if (weather != null)
        {
            switch (weather.Attribute("mode").Value)
            {
                case "rain":
                    Debug.Log("It's raining!");
                    RenderSettings.skybox = rainSkyboxMaterial;
                    break;
                case "snow":
                    Debug.Log("It's snowing!");
                    RenderSettings.skybox = snowSkyboxMaterial;
                    break;
                default:
                    Debug.Log("No precipitation.");
                    break;
            }
        }
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>üîê PlayFab Authentication System</h3>
                <p class="code-description">
                    Implemented a flexible authentication system supporting multiple login methods (email, 
                    device ID) through the Strategy pattern. The system includes persistent login sessions, 
                    automatic re-authentication, and secure credential storage. This was my introduction to 
                    backend-as-a-service (BaaS) platforms!
                </p>
                <div class="code-container">
                    <details>
                        <summary>ILogin.cs - Authentication Interface</summary>
                        <pre><code class="language-csharp">
using PlayFab.ClientModels;
using PlayFab;

// Strategy pattern interface for multiple login methods
public interface ILogin
{
    void Login(System.Action<LoginResult> onSuccess, System.Action<PlayFabError> onError);
}
                        </code></pre>
                    </details>
                    <details>
                        <summary>PlayFabManager.cs - Authentication Manager</summary>
                        <pre><code class="language-csharp">
using PlayFab. ClientModels;
using PlayFab;
using UnityEngine;

public class PlayFabManager : MonoBehaviour
{
    private LoginManager loginManager;
    private string savedEmailKey = "SavedEmail";
    private string userEmail;
    
    private void Start()
    {
        loginManager = new LoginManager();
        
        // Auto-login if credentials are saved
        if (PlayerPrefs.HasKey(savedEmailKey))
        {
            string savedEmail = PlayerPrefs.GetString(savedEmailKey);
            EmailLoginButtonClicked(savedEmail, "SavedPassword");
        }
    }
    
    public void EmailLoginButtonClicked(string email, string password)
    {
        userEmail = email;
        loginManager.SetLoginMethod(new EmailLogin(email, password));
        loginManager.Login(OnLoginSuccess, OnLoginFailure);
    }
    
    public void OnLoginSuccess(LoginResult result)
    {
        Debug. Log("Login successful!");
        
        // Persist email for future auto-login
        if (! string.IsNullOrEmpty(userEmail))
            PlayerPrefs.SetString(savedEmailKey, userEmail);
            
        LoadPlayerData(result.PlayFabId);
    }
    
    public void OnLoginFailure(PlayFabError error)
    {
        Debug.LogError("Login failed: " + error.ErrorMessage);
    }
    
    private void LoadPlayerData(string playFabId)
    {
        var request = new GetUserDataRequest
        {
            PlayFabId = playFabId
        };
        PlayFabClientAPI.GetUserData(request, OnDataSuccess, OnDataFailure);
    }
    
    private void OnDataSuccess(GetUserDataResult result)
    {
        // Load Player
        Debug.Log("Player data loaded successfully.");
    }
    
    private void OnDataFailure(PlayFabError error)
    {
        Debug.LogError("Failed to load player data: " + error.ErrorMessage);
    }
}
                        </code></pre>
                    </details>
                    <details>
                        <summary>EmailLogin.cs - Email Authentication Strategy</summary>
                        <pre><code class="language-csharp">
using PlayFab.ClientModels;
using PlayFab;

public class EmailLogin : ILogin
{
    public string Email { get; private set; }
    public string Password { get; private set; }

    public EmailLogin(string email, string password)
    {
        Email = email;
        Password = password;
    }

    public void Login(System.Action<LoginResult> onSuccess, System.Action<PlayFabError> onError)
    {
        var request = new LoginWithEmailAddressRequest
        {
            Email = Email,
            Password = Password
        };
        PlayFabClientAPI.LoginWithEmailAddress(request, onSuccess, onError);
    }
}
                        </code></pre>
                    </details>
                    <details>
                        <summary>DeviceLogin.cs - Device ID Authentication Strategy</summary>
                        <pre><code class="language-csharp">
using PlayFab. ClientModels;
using PlayFab;
using UnityEngine. iOS;

public class DeviceLogin :  ILogin
{
    private string deviceID;
    
    public DeviceLogin()
    {
        deviceID = Device.vendorIdentifier;
    }
    
    public void Login(System.Action<LoginResult> onSuccess, System.Action<PlayFabError> onError)
    {
        var request = new LoginWithCustomIDRequest
        {
            CustomId = deviceID,
            CreateAccount = true  // Auto-create account on first login
        };
        PlayFabClientAPI.LoginWithCustomID(request, onSuccess, onError);
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>üíæ Smart Image Caching System</h3>
                <p class="code-description">
                    Developed an optimized image loading system that caches downloaded images locally to reduce 
                    bandwidth and improve load times. The system downloads images from URLs on first access, 
                    stores them persistently, and retrieves from cache on subsequent loads.  Includes cache 
                    management for clearing old data. 
                </p>
                <div class="code-container">
                    <details>
                        <summary>BillboardImagePicker.cs - Cached Image Loading</summary>
                        <pre><code class="language-csharp">
using System;
using System.Collections;
using System.IO;
using UnityEngine;
using UnityEngine. Networking;

public class BillboardImagePicker : MonoBehaviour
{
    public string billboardID;
    public string[] imageUrls;

    private string localPath;
    private Renderer billboardRenderer;

    void Start()
    {
        billboardRenderer = GetComponent<Renderer>();
        int randomIndex = UnityEngine.Random.Range(0, imageUrls.Length);
        Debug.Log("Selected image URL: " + imageUrls[randomIndex]);
        
        // Generate cache path with unique identifier
        localPath = Application.persistentDataPath + "/" + billboardID + "_" + randomIndex + ".png";
        StartCoroutine(LoadImageFromURL(imageUrls[randomIndex], ApplyTexture));
    }

    private IEnumerator LoadImageFromURL(string url, Action<Texture2D> callback)
    {
        byte[] imageData;
        
        // Check if image is already cached
        if (! File.Exists(localPath))
        {
            // Download and cache image
            UnityWebRequest request = UnityWebRequestTexture.GetTexture(url);
            yield return request. SendWebRequest();
            Debug.Log("Downloading image from URL: " + url);
            
            imageData = DownloadHandlerTexture.GetContent(request).EncodeToPNG();
            File.WriteAllBytes(localPath, imageData);
        }
        else
        {
            // Load from cache
            Debug.Log("Loading image from cache: " + localPath);
            imageData = File.ReadAllBytes(localPath);
        }
        
        // Convert byte array to texture
        Texture2D texture = new Texture2D(2, 2);
        texture.LoadImage(imageData);
        callback(texture);
    }

    private void ApplyTexture(Texture2D texture)
    {
        billboardRenderer.material. mainTexture = texture;
    }

    public void ClearCachedImage()
    {
        // Clean up all cached images for this billboard
        for (int i = 0; i < imageUrls.Length; i++)
        {
            string path = Application.persistentDataPath + "/" + billboardID + "_" + i + ".png";
            if (File.Exists(path))
            {
                File.Delete(path);
                Debug.Log("Deleted cached image at: " + path);
            }
        }
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>

            <div class="code-feature">
                <h3>üì∏ Screenshot Capture Utility</h3>
                <p class="code-description">
                    Simple but effective screenshot tool with timestamped filenames. Perfect for capturing 
                    different weather conditions during testing and creating portfolio content! 
                </p>
                <div class="code-container">
                    <details>
                        <summary>ScreenshotTool.cs - Timestamped Screenshot System</summary>
                        <pre><code class="language-csharp">
using System;
using UnityEngine;

public class ScreenshotTool : MonoBehaviour
{
    public void TakeScreenshot()
    {
        // Generate timestamped filename
        string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
        string filename = $"Screenshot_{timestamp}.png";
        
        ScreenCapture.CaptureScreenshot(filename);
        Debug.Log($"Screenshot saved as {filename}");
    }
}
                        </code></pre>
                    </details>
                </div>
            </div>
        </section>

        <section class="learning-section">
            <h2>üéì Learning & Experimentation</h2>
            <div class="learning-grid">
                <div class="learning-card">
                    <h3>üåê API Integration</h3>
                    <p>
                        <strong>What I Learned:</strong> RESTful API consumption, XML parsing, asynchronous 
                        request handling, and error management. OpenWeatherMap taught me how to work with 
                        real-time external data sources.
                    </p>
                </div>
                <div class="learning-card">
                    <h3>‚òÅÔ∏è Cloud Services</h3>
                    <p>
                        <strong>What I Learned:</strong> Backend-as-a-Service platforms, user authentication 
                        flows, session management, and cloud data storage. PlayFab became my testing ground 
                        for understanding player accounts and persistent data.
                    </p>
                </div>
                <div class="learning-card">
                    <h3>‚ö° Performance Optimization</h3>
                    <p>
                        <strong>What I Learned:</strong> Local caching strategies, reducing network calls, 
                        efficient file I/O, and data persistence. These techniques significantly improved 
                        app responsiveness. 
                    </p>
                </div>
                <div class="learning-card">
                    <h3>üé® Dynamic Environments</h3>
                    <p>
                        <strong>What I Learned:</strong> Runtime material swapping, procedural skybox 
                        switching, dynamic lighting adjustments, and creating reactive game worlds that 
                        respond to real-world data.
                    </p>
                </div>
            </div>
        </section>

        <section class="reflection-section">
            <h2>üí≠ Developer Reflection</h2>
            <blockquote>
                Reactive Skies started as a simple class assignment but quickly became my favorite 
                experimentation space. Every time I want to test a new API, try out a cloud service, or 
                prototype a network feature, I come back to this project. It's taught me that some of the 
                best learning happens when you turn assignments into playgrounds‚Äîwhere mistakes are cheap 
                and creativity flows freely.  The weather integration was particularly satisfying; seeing 
                Unity's skybox change to match the actual weather outside my window felt like magic!  üå§Ô∏è‚ú®
            </blockquote>
        </section>
    </main>
</body>
</html>